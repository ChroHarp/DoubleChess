<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4å…ƒæ•¸ Node ç´€éŒ„è¡¨ - é‚Šç•Œæ¨æ¼”å‘ˆç¾ (Even Levels)</title>
    <!-- å¼•å…¥ html2canvas ç•«å¸ƒè½‰æ›å¥—ä»¶ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f4f4f9;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }

        /* ä¸Šæ–¹æ§åˆ¶åˆ—èˆ‡åˆ†é å™¨ */
        .header-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            z-index: 10;
        }

        .page-label {
            font-weight: bold;
            font-size: 16px;
            color: #2d3748;
            margin-right: auto;
        }

        .btn {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            background: #3182ce;
            color: white;
            border-radius: 6px;
            font-weight: bold;
            transition: 0.2s;
        }

        .btn.export {
            background: #38a169;
        }

        .btn.export:hover {
            background: #2f855a;
        }

        /* åŒæ­¥ç‹€æ…‹ç‡ˆè™Ÿ */
        .sync-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: bold;
            font-size: 14px;
            color: #4a5568;
            padding: 4px 10px;
            border-radius: 20px;
            background: #e2e8f0;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #a0aec0;
        }

        .status-dot.online {
            background: #48bb78;
            box-shadow: 0 0 5px #48bb78;
        }

        /* ç·Šå¯†æ¨¡å¼åˆ‡æ› */
        .compact-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: bold;
            color: #2d3748;
            cursor: pointer;
            padding: 6px 12px;
            background: #edf2f7;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            margin-left: 20px;
        }

        /* å…§å®¹å€åŸŸ */
        .tab-contents {
            flex-grow: 1;
            overflow: auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            position: relative;
        }

        /* æ¨¹ç‹€åœ–çµæ§‹ */
        .tree-container {
            display: flex;
            /* é‡è¦ï¼šåå‘æ’åˆ—ï¼Œè®“é™£åˆ—ç¬¬ä¸€ç­†ï¼ˆLv_0ï¼‰åœ¨æœ€ä¸‹é¢ï¼Œå¾ŒçºŒï¼ˆLv_2, Lv_4ï¼‰å¾€ä¸Šç–Š */
            flex-direction: column-reverse;
            align-items: center;
            gap: 80px;
            margin-top: 20px;
            padding: 40px;
            position: relative;
            background: white;
            min-width: max-content;
            min-height: max-content;
        }

        body.compact-mode .tree-container {
            gap: 15px !important;
            padding-top: 15px !important;
        }

        .tree-row {
            display: flex;
            justify-content: center;
            gap: 45px;
            position: relative;
            z-index: 2;
        }

        body.compact-mode .tree-row {
            gap: 10px !important;
        }

        /* èƒŒæ™¯ç®­é ­ç•«å¸ƒ */
        .tree-svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
        }

        /* Node æ¨£å¼ */
        .node {
            min-width: 64px;
            min-height: 64px;
            display: grid;
            grid-auto-flow: column;
            grid-template-rows: auto auto;
            grid-template-columns: auto auto;
            gap: 4px;
            border: 3px solid #718096;
            padding: 6px;
            border-radius: 8px;
            background-color: #ffffff;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .node.green {
            background-color: #c6f6d5;
            border-color: #38a169;
        }

        .node.red {
            background-color: #fed7d7;
            border-color: #e53e3e;
        }

        /* è¼¸å…¥æ¡†æ¨£å¼ (å”¯è®€éœæ…‹) */
        .node input {
            width: 3ch;
            min-width: 3ch;
            border: 1px solid transparent;
            text-align: center;
            font-size: 16px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            background: transparent;
            box-sizing: border-box;
            outline: none;
            border-radius: 3px;
            padding: 2px 4px;
            pointer-events: none;
            /* å®Œå…¨ä¸å¯é»æ“Š */
        }

        /* æ¨™ç±¤ (Lv_n æ¨™ç¤º) */
        .row-label {
            position: absolute;
            left: -80px;
            top: 50%;
            transform: translateY(-50%);
            font-weight: bold;
            color: #718096;
            background: #e2e8f0;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
        }
    </style>
</head>

<body>

    <div class="header-controls">
        <span class="page-label">æ¨æ¼”é‚Šç•Œå‘ˆç¾ (Extracting Last Rows of Even Levels)</span>
        <div class="sync-status" id="sync-status">
            <div class="status-dot" id="status-dot"></div>
            <span id="status-text">é€£ç·šè¼‰å…¥ä¸­...</span>
        </div>

        <label class="compact-toggle">
            <input type="checkbox" id="compactModeToggle" onchange="window.toggleCompactMode(event)"> ç·Šå¯†æ¨¡å¼
        </label>

        <button class="btn export" onclick="window.exportToImage()">ğŸ–¼ï¸ åŒ¯å‡ºç•¶å‰ç•«é¢</button>
        <button class="btn" style="background:#4a5568;" onclick="window.location.href='index.html'">ğŸ  è¿”å›ç·¨è¼¯é¦–é 
            (index.html)</button>
    </div>

    <div class="tab-contents" id="tab-contents">
        <div class="tree-container" id="edge-container">
            <svg class="tree-svg" id="edge-svg">
                <defs>
                    <marker id="arrow-edge" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="5" markerHeight="5"
                        orient="auto-start-reverse">
                        <path d="M 0 0 L 10 5 L 0 10 z" fill="#a0aec0" />
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <!-- å¼•å…¥ Firebase v10 SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-app.js";
        import { getFirestore, doc, onSnapshot, initializeFirestore, persistentLocalCache, persistentMultipleTabManager } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js";

        // 1. Firebase åˆå§‹åŒ–
        const firebaseConfig = {
            apiKey: "AIzaSyDvHGQqXkdPx496CSDMQ_aU7Q6wbz28D-g",
            authDomain: "doublechess-fe12e.firebaseapp.com",
            projectId: "doublechess-fe12e",
            storageBucket: "doublechess-fe12e.firebasestorage.app",
            messagingSenderId: "1062731143335",
            appId: "1:1062731143335:web:a69ea9a1bc97798f37a382"
        };

        const app = initializeApp(firebaseConfig);
        const db = initializeFirestore(app, {
            localCache: persistentLocalCache({ tabManager: persistentMultipleTabManager() })
        });
        const docRef = doc(db, 'research_data', 'board_state');

        function setSyncStatus(status) {
            const dot = document.getElementById('status-dot');
            const text = document.getElementById('status-text');
            dot.className = 'status-dot';
            if (status === 'online') {
                dot.classList.add('online'); text.innerText = 'å·²èˆ‡é›²ç«¯åŒæ­¥ (å”¯è®€)';
            } else {
                text.innerText = 'é›¢ç·š / éŒ¯èª¤';
            }
        }

        // å°‡ Maps æˆ– Arrays çš„ Firebase Payload æ­£è¦åŒ–ç‚ºé™£åˆ—
        function normalizeToArray(data) {
            if (!data) return [];
            if (Array.isArray(data)) return data;

            const keys = Object.keys(data);
            if (keys.length === 0) return [];

            // å¦‚æœ key æ˜¯ç´”æ•¸å­— (ä¾‹å¦‚ r æˆ– i)ï¼Œå°±ç…§æ•¸å­—æ’åº
            if (!isNaN(parseInt(keys[0]))) {
                const numericKeys = keys.filter(k => !isNaN(parseInt(k))).sort((a, b) => parseInt(a) - parseInt(b));
                return numericKeys.map(k => data[k]);
            }
            // å¦‚æœ key æ˜¯æ–‡å­— (ä¾‹å¦‚ Lv_0)ï¼Œç›´æ¥å›å‚³ values ä¸¦ç¨å¾Œæ’åº
            return Object.values(data);
        }

        // æ¥æ”¶è³‡æ–™ä¸¦ç¹ªè£½ Edge è¦–åœ–
        function renderEdgeView(rawState) {
            const container = document.getElementById('edge-container');
            const svg = document.getElementById('edge-svg');

            // æ¸…é™¤é™¤äº† SVG ä»¥å¤–çš„èˆŠç¯€é»
            Array.from(container.children).forEach(child => {
                if (child.tagName.toLowerCase() !== 'svg') {
                    container.removeChild(child);
                }
            });
            // æ¸…ç©º SVG å…§çš„ç·šæ¢ (ä¿ç•™ defs)
            const defs = svg.querySelector('defs');
            svg.innerHTML = '';
            if (defs) svg.appendChild(defs);

            // 1. æ•´ç†å„å±¤ç´šçš„æœ€å¾Œä¸€åˆ—
            let edgeRowsData = []; // [{ lvName: 'Lv_0', nodes: [...] }, { lvName: 'Lv_2', nodes: [...] }]

            const tabsArray = normalizeToArray(rawState);

            // æ‰¾å‡ºæ‰€æœ‰å¶æ•¸çš„ Lv
            const evenTabs = tabsArray.filter(t => {
                const match = t.id.match(/Lv_(\d+)/);
                if (match) {
                    const n = parseInt(match[1]);
                    return n % 2 === 0;
                }
                return false;
            }).sort((a, b) => {
                return parseInt(a.id.match(/Lv_(\d+)/)[1]) - parseInt(b.id.match(/Lv_(\d+)/)[1]);
            });

            evenTabs.forEach(tab => {
                const rowsArray = normalizeToArray(tab.rows);
                if (rowsArray.length > 0) {
                    // å–å¾—è©²åˆ†é (Level)çš„æœ€å¾Œä¸€åˆ—
                    const lastRow = rowsArray[rowsArray.length - 1];
                    edgeRowsData.push({
                        lvName: tab.id,
                        nodes: normalizeToArray(lastRow.nodes)
                    });
                }
            });

            // 2. å»ºç«‹ DOM å…ƒç´ 
            // ç”±æ–¼ container æ¡ç”¨ column-reverseï¼Œæˆ‘å€‘æŒ‰ç…§ 0, 2, 4 é †åº appendï¼ŒLv_0 æœƒåœ¨æœ€ä¸‹é¢
            edgeRowsData.forEach((rowData, index) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'tree-row';
                rowDiv.dataset.r = index; // é€™è£¡çš„ r åªæ˜¯ä»£è¡¨å®ƒæ˜¯ç¬¬å¹¾ç–Š
                rowDiv.dataset.lv = rowData.lvName;

                // åŠ ä¸Šå´é‚Šæ¨™ç±¤
                const label = document.createElement('div');
                label.className = 'row-label';
                label.innerText = rowData.lvName;
                rowDiv.appendChild(label);

                rowData.nodes.forEach(nodeData => {
                    const node = document.createElement('div');
                    node.className = `node ${nodeData.color || 'white'}`;
                    node.dataset.i = nodeData.i; // ä¿æŒåŸæœ¬åœ¨è©²åˆ—ä¸­çš„åŸå§‹ç´¢å¼•

                    ['a', 'b', 'c', 'd'].forEach(pos => {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.value = nodeData.vals ? (nodeData.vals[pos] || '') : '';
                        input.readOnly = true;
                        input.style.width = Math.max(3, input.value.length + 1) + 'ch';
                        node.appendChild(input);
                    });
                    rowDiv.appendChild(node);
                });

                container.appendChild(rowDiv);
            });

            // å»¶é²ç¹ªè£½ç®­é ­ï¼Œç¢ºä¿ DOM å·²å®šä½
            setTimeout(() => {
                drawEdgeArrows(edgeRowsData);
            }, 100);
        }

        function drawEdgeArrows(edgeRowsData) {
            const container = document.getElementById('edge-container');
            const svg = document.getElementById('edge-svg');

            // è¨­å®šç•«å¸ƒå°ºå¯¸
            svg.style.width = container.scrollWidth + 'px';
            svg.style.height = container.scrollHeight + 'px';
            const containerRect = container.getBoundingClientRect();
            const isCompact = document.body.classList.contains('compact-mode');

            // è¼”åŠ©å‡½å¼ï¼šç•« SVG ç·š
            const drawLine = (startX, startY, endX, endY) => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', startX); line.setAttribute('y1', startY);
                line.setAttribute('x2', endX); line.setAttribute('y2', endY);
                line.setAttribute('stroke', '#a0aec0');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('marker-end', `url(#arrow-edge)`);
                svg.appendChild(line);
            };

            const rows = Array.from(container.querySelectorAll('.tree-row'));

            // æ”¹ç”±æœ€é ‚å±¤ (DOMè£¡çš„æœ€å¾Œ1å€‹ï¼Œå³ç´¢å¼•æœ€å¤§çš„Lv) é–‹å§‹å¾€ä¸‹éæ­·ï¼Œå› ç‚ºç®­é ­æ–¹å‘æ˜¯ç”±ä¸Šå¾€ä¸‹
            for (let rIndex = rows.length - 1; rIndex >= 0; rIndex--) {
                const currentRow = rows[rIndex];
                const prevRow = rIndex - 1 >= 0 ? rows[rIndex - 1] : null; // ä¸‹æ–¹çš„é‚£ä¸€åˆ—

                const currentNodes = Array.from(currentRow.querySelectorAll('.node'));
                if (currentNodes.length === 0) continue;

                const currentCenterI = (currentNodes.length - 1) / 2; // ç•¶å‰åˆ—çš„ä¸­è»¸ç´¢å¼•

                currentNodes.forEach((fromNode, domIndex) => {
                    const rectFrom = fromNode.getBoundingClientRect();
                    const offsetFromCenter = domIndex - currentCenterI; // å·¦å´(-), ä¸­è»¸(0), å³å´(+)
                    const offsetGap = isCompact ? 2 : 12;

                    // 1. ä¸­è»¸ç¯€é» (offset == 0)ï¼šä¸‹ã€å·¦ã€å³
                    // 2. å·¦å´ç¯€é» (offset < 0)ï¼šä¸‹ã€å·¦ã€å³ä¸‹
                    // 3. å³å´ç¯€é» (offset > 0)ï¼šä¸‹ã€å³ã€å·¦ä¸‹

                    // ================= A. è™•ç†æ©«å‘ç®­é ­ (åŒåˆ—) =================
                    if (offsetFromCenter <= 0 && domIndex > 0) {
                        // ä¸­è»¸æˆ–å·¦å´ï¼šå‘å·¦ç•« (å·¦)
                        const leftNode = currentNodes[domIndex - 1];
                        const rectTo = leftNode.getBoundingClientRect();
                        const startX = rectFrom.left - containerRect.left + container.scrollLeft;
                        const startY = rectFrom.top + rectFrom.height / 2 - containerRect.top + container.scrollTop;
                        const endX = rectTo.right - containerRect.left + container.scrollLeft;
                        const endY = rectTo.top + rectTo.height / 2 - containerRect.top + container.scrollTop;
                        drawLine(startX, startY, endX + offsetGap, endY);
                    }
                    if (offsetFromCenter >= 0 && domIndex < currentNodes.length - 1) {
                        // ä¸­è»¸æˆ–å³å´ï¼šå‘å³ç•« (å³)
                        const rightNode = currentNodes[domIndex + 1];
                        const rectTo = rightNode.getBoundingClientRect();
                        const startX = rectFrom.right - containerRect.left + container.scrollLeft;
                        const startY = rectFrom.top + rectFrom.height / 2 - containerRect.top + container.scrollTop;
                        const endX = rectTo.left - containerRect.left + container.scrollLeft;
                        const endY = rectTo.top + rectTo.height / 2 - containerRect.top + container.scrollTop;
                        drawLine(startX, startY, endX - offsetGap, endY);
                    }

                    // ================= B. è™•ç†å‘ä¸‹çš„å‚ç›´èˆ‡æ–œå‘ç®­é ­ (è·¨åˆ—) =================
                    if (prevRow) {
                        const prevNodes = Array.from(prevRow.querySelectorAll('.node'));
                        if (prevNodes.length === 0) return;
                        const prevCenterI = (prevNodes.length - 1) / 2; // ä¸‹æ–¹çš„ä¸­è»¸ç´¢å¼•

                        // æ‰€æœ‰äººéƒ½æœ‰ã€Œå¾€ä¸‹ã€çš„å‚ç›´é€£ç·š (ä¸‹)
                        const targetDownDomIndex = prevCenterI + offsetFromCenter;
                        if (targetDownDomIndex >= 0 && targetDownDomIndex < prevNodes.length) {
                            const downNode = prevNodes[targetDownDomIndex];
                            const rectTo = downNode.getBoundingClientRect();
                            const startX = rectFrom.left + rectFrom.width / 2 - containerRect.left + container.scrollLeft;
                            const startY = rectFrom.bottom - containerRect.top + container.scrollTop;
                            const endX = rectTo.left + rectTo.width / 2 - containerRect.left + container.scrollLeft;
                            const endY = rectTo.top - containerRect.top + container.scrollTop;
                            drawLine(startX, startY, endX, endY - 4);
                        }

                        // æ–œå‘é€£ç·š
                        if (offsetFromCenter < 0) {
                            // å·¦å´ç¯€é»ï¼šå¾€ã€Œå³ä¸‹ã€é€£ç·š
                            const targetDiagDomIndex = targetDownDomIndex + 1;
                            if (targetDiagDomIndex >= 0 && targetDiagDomIndex < prevNodes.length) {
                                const diagNode = prevNodes[targetDiagDomIndex];
                                const rectTo = diagNode.getBoundingClientRect();
                                const startX = rectFrom.left + rectFrom.width / 2 - containerRect.left + container.scrollLeft;
                                const startY = rectFrom.bottom - containerRect.top + container.scrollTop;
                                const endX = rectTo.left + rectTo.width / 2 - containerRect.left + container.scrollLeft - (isCompact ? 8 : 12);
                                const endY = rectTo.top - containerRect.top + container.scrollTop;
                                drawLine(startX, startY, endX, endY - 4);
                            }
                        } else if (offsetFromCenter > 0) {
                            // å³å´ç¯€é»ï¼šå¾€ã€Œå·¦ä¸‹ã€é€£ç·š
                            const targetDiagDomIndex = targetDownDomIndex - 1;
                            if (targetDiagDomIndex >= 0 && targetDiagDomIndex < prevNodes.length) {
                                const diagNode = prevNodes[targetDiagDomIndex];
                                const rectTo = diagNode.getBoundingClientRect();
                                const startX = rectFrom.left + rectFrom.width / 2 - containerRect.left + container.scrollLeft;
                                const startY = rectFrom.bottom - containerRect.top + container.scrollTop;
                                const endX = rectTo.left + rectTo.width / 2 - containerRect.left + container.scrollLeft + (isCompact ? 8 : 12);
                                const endY = rectTo.top - containerRect.top + container.scrollTop;
                                drawLine(startX, startY, endX, endY - 4);
                            }
                        }
                    }
                });
            }
        }

        // ================= å…¨å±€è¦–çª—äº‹ä»¶ =================
        window.addEventListener('resize', () => {
            // ç°¡å–®é‡ç¹ª
            const currentRawState = window.__lastRawState;
            if (currentRawState) renderEdgeView(currentRawState);
        });

        window.toggleCompactMode = function (e) {
            if (e.target.checked) document.body.classList.add('compact-mode');
            else document.body.classList.remove('compact-mode');

            const currentRawState = window.__lastRawState;
            if (currentRawState) renderEdgeView(currentRawState);
        };

        window.exportToImage = function () {
            const activeTab = document.getElementById('edge-container');
            if (!activeTab) return;

            html2canvas(activeTab, { backgroundColor: "#ffffff", scale: 2 }).then(canvas => {
                const link = document.createElement('a');
                const dateStr = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                link.download = `Edge_View_${dateStr}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            });
        };

        // ================= ç¶å®šé›²ç«¯å³æ™‚è¼‰å…¥ =================
        onSnapshot(docRef, (docSnap) => {
            if (docSnap.exists() && docSnap.data().state) {
                window.__lastRawState = docSnap.data().state;
                renderEdgeView(docSnap.data().state);
                setSyncStatus('online');
            }
        }, (error) => {
            console.error("Firestore ç›£è½å¤±æ•—", error);
            setSyncStatus('error');
        });

    </script>
</body>

</html>