<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4å…ƒæ•¸ Node ç´€éŒ„è¡¨ - é›²ç«¯å…±ç·¨ç‰ˆ</title>
  <!-- å¼•å…¥ html2canvas ç•«å¸ƒè½‰æ›å¥—ä»¶ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f4f4f9;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      height: 100vh;
      box-sizing: border-box;
    }

    /* ä¸Šæ–¹æ§åˆ¶åˆ—èˆ‡åˆ†é å™¨ */
    .header-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      z-index: 10;
    }

    .pagination {
      display: flex;
      align-items: center;
      gap: 15px;
      background: #edf2f7;
      padding: 4px 12px;
      border-radius: 6px;
      border: 1px solid #cbd5e0;
      flex-grow: 1;
      justify-content: center;
    }

    .page-btn {
      cursor: pointer;
      border: none;
      background: #cbd5e0;
      border-radius: 4px;
      padding: 6px 16px;
      font-weight: bold;
      font-size: 14px;
      color: #2d3748;
      transition: 0.2s;
    }

    .page-btn:hover:not(:disabled) {
      background: #a0aec0;
    }

    .page-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .page-label {
      font-weight: bold;
      font-size: 16px;
      color: #2d3748;
      min-width: 80px;
      text-align: center;
    }

    .btn {
      padding: 8px 16px;
      cursor: pointer;
      border: none;
      background: #3182ce;
      color: white;
      border-radius: 6px;
      font-weight: bold;
      transition: 0.2s;
    }

    .btn:hover {
      background: #2b6cb0;
    }

    .btn.export {
      background: #38a169;
    }

    .btn.export:hover {
      background: #2f855a;
    }

    .btn.save {
      background: #d69e2e;
    }

    .btn.save:hover {
      background: #b7791f;
    }

    .btn.load {
      background: #805ad5;
    }

    .btn.load:hover {
      background: #6b46c1;
    }

    .btn.undo {
      background: #e53e3e;
    }

    .btn.undo:hover {
      background: #c53030;
    }

    /* åŒæ­¥ç‹€æ…‹ç‡ˆè™Ÿ */
    .sync-status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: bold;
      font-size: 14px;
      color: #4a5568;
      padding: 4px 10px;
      border-radius: 20px;
      background: #e2e8f0;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #a0aec0;
    }

    .status-dot.online {
      background: #48bb78;
      box-shadow: 0 0 5px #48bb78;
    }

    .status-dot.syncing {
      background: #ecc94b;
      box-shadow: 0 0 5px #ecc94b;
    }

    #fileInput {
      display: none;
    }

    /* å…§å®¹å€åŸŸ */
    .tab-contents {
      flex-grow: 1;
      overflow: auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      position: relative;
    }

    .tab-content {
      display: none;
      min-width: max-content;
      padding: 20px;
    }

    .tab-content.active {
      display: block;
    }

    /* é–å®šç›¸é—œ UI æ¨£å¼ */
    .locked-banner {
      background: #fed7d7;
      color: #c53030;
      padding: 10px;
      text-align: center;
      font-weight: bold;
      border-radius: 6px;
      margin-bottom: 15px;
      border: 1px solid #fc8181;
      font-size: 15px;
    }

    .tab-content.locked .node {
      border-color: #cbd5e0 !important;
      background: #f7fafc !important;
      pointer-events: none;
      /* é˜²æ­¢ hover å–šå‡º O / X æŒ‰éˆ• */
    }

    .tab-content.locked input,
    .tab-content.locked button {
      cursor: not-allowed !important;
      opacity: 0.6;
    }

    /* æ¨¹ç‹€åœ–çµæ§‹ */
    .tree-container {
      display: flex;
      flex-direction: column-reverse;
      align-items: center;
      gap: 80px;
      margin-top: 20px;
      padding: 40px;
      position: relative;
      background: white;
    }

    .tree-row {
      display: flex;
      justify-content: center;
      gap: 45px;
      position: relative;
      z-index: 2;
    }

    /* åƒç…§åˆ—æ¨£å¼ */
    .ref-row {
      opacity: 0.8;
      padding-bottom: 30px;
      margin-bottom: 10px;
      border-bottom: none;
    }

    body.compact-mode .tree-container {
      gap: 10px !important;
      padding-top: 10px !important;
    }

    body.compact-mode .tree-row {
      gap: 10px !important;
    }

    body.compact-mode .ref-row {
      display: none !important;
    }

    .compact-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: bold;
      color: #2d3748;
      cursor: pointer;
      padding: 6px 12px;
      background: #edf2f7;
      border: 1px solid #cbd5e0;
      border-radius: 6px;
      margin-left: auto;
    }

    .ref-label {
      position: absolute;
      bottom: calc(100% + 5px);
      left: 50%;
      transform: translateX(-50%);
      color: #718096;
      font-weight: bold;
      font-size: 14px;
      background: white;
      padding: 5px 10px;
      border-radius: 6px;
      white-space: nowrap;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 15px;
      z-index: 10;
    }

    .ref-node {
      cursor: not-allowed !important;
      transform: scale(0.95);
    }

    .ref-node input {
      cursor: not-allowed;
      pointer-events: none;
      background: rgba(255, 255, 255, 0.3) !important;
      border-color: transparent !important;
    }

    /* èƒŒæ™¯ç®­é ­ç•«å¸ƒ */
    .tree-svg {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 1;
    }

    /* Node æ¨£å¼ */
    .node {
      min-width: 64px;
      min-height: 64px;
      display: grid;
      grid-auto-flow: column;
      grid-template-rows: auto auto;
      grid-template-columns: auto auto;
      gap: 4px;
      border: 3px solid #718096;
      padding: 6px;
      border-radius: 8px;
      background-color: #ffffff;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
      position: relative;
      transition: border-color 0.2s, background-color 0.2s;
    }

    /* æ§åˆ¶åƒç…§å±¤é¡¯ç¤º/éš±è— */
    .hide-ref-layer .exp-node {
      display: none !important;
    }

    .node.green {
      background-color: #c6f6d5;
      border-color: #38a169;
    }

    .node.red {
      background-color: #fed7d7;
      border-color: #e53e3e;
    }

    /* æ¸¸æ¨™æ‡¸åœæ™‚çš„ O èˆ‡ X é¸æ“‡å™¨ */
    .node:not(.ref-node) .color-picker {
      position: absolute;
      top: -38px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 6px;
      background: #ffffff;
      padding: 5px;
      border-radius: 6px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      border: 1px solid #cbd5e0;
      z-index: 100;
    }

    .node:hover:not(.ref-node) .color-picker {
      display: flex;
    }

    .btn-color {
      width: 26px;
      height: 26px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-weight: bold;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .btn-color.btn-green {
      background: #38a169;
    }

    .btn-color.btn-red {
      background: #e53e3e;
    }

    .btn-color:hover {
      filter: brightness(1.1);
    }

    /* è¼¸å…¥æ¡†æ¨£å¼ */
    .node input {
      width: 3ch;
      min-width: 3ch;
      border: 1px solid #e2e8f0;
      text-align: center;
      font-size: 16px;
      font-family: 'Courier New', Courier, monospace;
      font-weight: bold;
      background: rgba(255, 255, 255, 0.6);
      box-sizing: border-box;
      outline: none;
      border-radius: 3px;
      padding: 2px 4px;
      transition: border 0.1s;
    }

    .node input:focus {
      border: 2px solid #3182ce;
      background: #fff;
    }

    /* æ“ä½œæ‰‹å†Š Modal æ¨£å¼ */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background: #fff;
      padding: 30px 40px;
      border-radius: 12px;
      width: 80%;
      max-width: 800px;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      position: relative;
      line-height: 1.6;
      color: #2d3748;
    }

    .modal-content h1,
    .modal-content h2,
    .modal-content h3 {
      color: #1a202c;
      margin-top: 1.5em;
      margin-bottom: 0.5em;
    }

    .modal-content h1 {
      margin-top: 0;
      border-bottom: 2px solid #e2e8f0;
      padding-bottom: 10px;
    }

    .modal-content hr {
      border: 0;
      border-top: 1px solid #e2e8f0;
      margin: 20px 0;
    }

    .modal-content ul,
    .modal-content ol {
      padding-left: 20px;
    }

    .modal-content li {
      margin-bottom: 8px;
    }

    .modal-content code {
      background: #edf2f7;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
    }

    .modal-content blockquote {
      border-left: 4px solid #3182ce;
      margin: 0;
      padding-left: 15px;
      color: #4a5568;
    }

    .close-btn {
      position: absolute;
      top: 20px;
      right: 25px;
      font-size: 28px;
      font-weight: bold;
      color: #a0aec0;
      cursor: pointer;
      transition: color 0.2s;
      line-height: 1;
    }

    .close-btn:hover {
      color: #e53e3e;
    }

    .btn.help {
      background: #ed8936;
      /* Orange */
    }

    .btn.help:hover {
      background: #dd6b20;
    }
  </style>
</head>

<body class="hide-ref-layer">

  <div class="header-controls">
    <button class="btn" onclick="window.createTab()">+ æ–°å¢ Lv åˆ†é </button>
    <div class="pagination">
      <button class="page-btn" id="prev-btn" onclick="window.prevTab()" disabled>â—€ ä¸Šä¸€é </button>
      <span class="page-label" id="current-tab-label">è¼‰å…¥ä¸­...</span>
      <button class="page-btn" id="next-btn" onclick="window.nextTab()" disabled>ä¸‹ä¸€é  â–¶</button>
    </div>

    <div class="sync-status" id="sync-status">
      <div class="status-dot" id="status-dot"></div>
      <span id="status-text">é€£ç·šä¸­...</span>
    </div>

    <label class="compact-toggle">
      <input type="checkbox" id="compactModeToggle" onchange="window.toggleCompactMode(event)"> ç·Šå¯†æ¨¡å¼
    </label>
    <button class="btn help" onclick="document.getElementById('helpModal').style.display='flex'">ğŸ“– æ“ä½œæ‰‹å†Š</button>
    <button class="btn export" onclick="window.exportToImage()">ğŸ–¼ï¸ åŒ¯å‡ºç•¶å‰ç•«é¢</button>
    <button class="btn save" onclick="window.saveData()">ğŸ’¾ å‚™ä»½ (JSON)</button>
    <button class="btn load" onclick="document.getElementById('fileInput').click()">ğŸ“‚ åŒ¯å…¥è¦†è“‹</button>
    <input type="file" id="fileInput" accept=".json" onchange="window.loadData(event)">
  </div>

  <div class="tab-contents" id="tab-contents"></div>

  <!-- æ“ä½œæ‰‹å†Š Modal -->
  <div id="helpModal" class="modal">
    <div class="modal-content">
      <span class="close-btn" onclick="document.getElementById('helpModal').style.display='none'">&times;</span>

      <h1>ğŸ¯ 4å…ƒæ•¸ Node ç´€éŒ„è¡¨ - å­¸ç”Ÿæ“ä½œæ‰‹å†Š</h1>
      <p>æ­¡è¿ä¾†åˆ° <strong>4å…ƒæ•¸ Node ç´€éŒ„è¡¨</strong>ï¼é€™æ˜¯ä¸€å€‹å¹«åŠ©ä½ é€²è¡ŒçŸ©é™£èˆ‡ç¯€é»æ•¸å€¼æ¨æ¼”çš„è¦–è¦ºåŒ–å·¥å…·ã€‚æ‰€æœ‰çš„ç´€éŒ„éƒ½æœƒ<strong>å³æ™‚åŒæ­¥åˆ°é›²ç«¯</strong>ï¼Œè®“ä½ èˆ‡çµ„å“¡å€‘å¯ä»¥è¼•é¬†å…±ç·¨èˆ‡è¨è«–ã€‚
      </p>
      <p>æœ¬æ‰‹å†Šæœƒæ•™ä½ å¦‚ä½•å»ºç«‹åˆ†é ã€æ–°å¢æ•¸å€¼ã€ä»¥åŠåˆ©ç”¨ç–ŠåŠ åƒç…§å±¤ä¾†æ¨å°è¦å¾‹ã€‚</p>
      <hr>

      <h2>ğŸš€ 1. ä»‹é¢åŸºæœ¬æ“ä½œ</h2>
      <h3>å»ºç«‹èˆ‡åˆ‡æ›ã€ŒLv åˆ†é ã€</h3>
      <p>åœ¨æœ€ä¸Šæ–¹çš„æ§åˆ¶åˆ—ï¼Œä½ å¯ä»¥çœ‹åˆ°å„ç¨®æŒ‰éˆ•ï¼š</p>
      <ul>
        <li><strong>ã€Œ+ æ–°å¢ Lv åˆ†é ã€</strong>ï¼šç•¶ä½ å®Œæˆç•¶å‰å±¤ç´š (Level) çš„æ¨æ¼”å¾Œï¼ŒæŒ‰æ­¤æŒ‰éˆ•æœƒå»ºç«‹æ–°çš„ä¸€é ï¼ˆä¾‹å¦‚å¾ Lv 0 æ¨é€²åˆ° Lv 1ï¼‰ã€‚</li>
        <li><strong>åˆ†é åˆ‡æ›å™¨</strong>ï¼šåˆ©ç”¨ã€Œâ—€ ä¸Šä¸€é ã€èˆ‡ã€Œä¸‹ä¸€é  â–¶ã€æŒ‰éˆ•ï¼Œåœ¨ä¸åŒçš„æ¨æ¼”æ­¥é©Ÿé–“ä¾†å›æª¢è¦–ã€‚</li>
      </ul>

      <h3>åœ¨åˆ†é ä¸­å¢åŠ è³‡æ–™åˆ—</h3>
      <ul>
        <li><strong>ã€Œâ¬†ï¸ å¾€ä¸Šæ–°å¢ä¸€åˆ— Node (+2)ã€</strong>ï¼šé»æ“Šå¾Œï¼Œæœƒåœ¨ç¾æœ‰çš„æ¨¹ç‹€åœ–é ‚ç«¯å†å¾€ä¸Šé•·å‡ºä¸€æ•´åˆ—çŸ©é™£ï¼Œæ¯ä¸€åˆ—çš„ç¯€é»æ•¸é‡æœƒæ¯”ä¸‹ä¸€åˆ—å¤š 2 å€‹ï¼Œæ–¹ä¾¿ä½ å±•é–‹æ¨æ¼”è„ˆçµ¡ã€‚</li>
        <li><strong>ã€Œâ¬‡ï¸ åˆªé™¤æœ€ä¸Šåˆ— (é‚„åŸ)ã€</strong>ï¼šå¦‚æœæŒ‰éŒ¯äº†æˆ–è€…æ¨æ¼”æ–¹å‘æœ‰èª¤ï¼Œé»æ“Šå³å¯ç§»é™¤æœ€ä¸Šé¢çš„ä¸€åˆ—ã€‚</li>
      </ul>
      <hr>

      <h2>ğŸ§® 2. ç·¨è¼¯èˆ‡æ¨™è¨˜çŸ©é™£ (Nodes)</h2>
      <p>ç•«é¢ä¸Šçš„æ¯ä¸€å€‹æ–¹å¡Šï¼Œéƒ½ä»£è¡¨ä¸€å€‹ <strong>2x2 çš„çŸ©é™£</strong>ï¼Œå…§éƒ¨åŒ…å«å››å€‹æ•¸å­— (a, c åœ¨ç¬¬ä¸€æ’ï¼Œb, d åœ¨ç¬¬äºŒæ’)ã€‚</p>

      <h3>è¼¸å…¥æ•¸å€¼</h3>
      <ol>
        <li>ç›´æ¥é»æ“Š Node å…§çš„ç™½è‰²å°æ¡†æ¡†å³å¯æ‰“å­—è¼¸å…¥ä»£æ•¸æˆ–æ•¸å­—ã€‚</li>
        <li><strong>éµç›¤å¿«é€Ÿå°è¦½</strong>ï¼šä½¿ç”¨éµç›¤çš„ <strong>ã€Œä¸Šã€ä¸‹ã€å·¦ã€å³æ–¹å‘éµã€</strong>ï¼Œå¯ä»¥åœ¨æ ¼å­ä¹‹é–“å¿«é€Ÿè·³èºç§»å‹•ï¼Œä¸éœ€è¦ä¸€ç›´ç”¨æ»‘é¼ é»æ“Šã€‚</li>
      </ol>

      <h3>æ¨™è¨˜ç¯€é»ç‹€æ…‹ O èˆ‡ X</h3>
      <p>ç•¶ä½ éœ€è¦æ¨™è¨˜å“ªå€‹ç¯€é»ç¬¦åˆç‰¹å®šè¦å¾‹æ¢ä»¶ï¼ˆå‹/æ•—é»ï¼‰ï¼Œä½ å¯ä»¥ï¼š</p>
      <ol>
        <li>å°‡æ»‘é¼ <strong>åœç•™åœ¨è©²æ–¹å¡Š (Node) çš„ä¸Šæ–¹</strong>ã€‚</li>
        <li>æ–¹å¡Šä¸Šæ–¹æœƒæµ®ç¾ <strong>ç¶ è‰²ã€ŒOã€</strong> èˆ‡ <strong>ç´…è‰²ã€ŒXã€</strong> å°æŒ‰éˆ•ã€‚</li>
        <li>é»æ“Šå°æ‡‰æŒ‰éˆ•ï¼Œæ–¹å¡Šå°±æœƒè®Šè‰²ï¼Œæ–¹ä¾¿ä½ è¦–è¦ºåŒ–çµ±æ•´è¦å¾‹ï¼<br>
          <em>è¨»ï¼šå¦‚æœæ¨™è¨˜éŒ¯èª¤ï¼Œå†é»æ“Šä¸€æ¬¡åŒä¸€å€‹æŒ‰éˆ•å°±æœƒæ¢å¾©ç™½è‰²ã€‚</em>
        </li>
      </ol>
      <hr>

      <h2>ğŸ” 3. ç–ŠåŠ åƒç…§å±¤ (Reference Layer) - é€²éšåŠŸèƒ½</h2>
      <p>ç‚ºäº†å¹«åŠ©ä½ è§€å¯Ÿåœ–å½¢çš„ç”Ÿé•·è¦å¾‹èˆ‡éè¿´é—œä¿‚ï¼Œç³»çµ±æœƒåœ¨ <strong>Lv 1 ä»¥ä¸Š</strong> çš„åˆ†é ä¸­å•Ÿç”¨ã€Œåƒç…§å±¤ã€æ©Ÿåˆ¶ï¼</p>

      <h3>å”¯ç¨åƒç…§åˆ—</h3>
      <p>åœ¨æ¨¹ç‹€åœ–çš„æœ€é ‚ç«¯ï¼Œä½ æœƒçœ‹åˆ°ä¸€åˆ—åŠé€æ˜ã€ç„¡æ³•ç·¨è¼¯çš„æ•¸å­—æ¡†ï¼Œä¸Šæ–¹æ¨™ç¤ºè‘— <strong><code>[ åƒç…§è‡ª Lv ... ]</code></strong>ã€‚<br>
        é€™ä»£è¡¨é€™ä¸€åˆ—çš„æ•¸å­—ï¼Œæ˜¯ç³»çµ±è‡ªå‹•å¹«ä½ å¾å…ˆå‰çš„æ¨æ¼”æ­¥é©Ÿä¸­æå–å‡ºä¾†çš„ï¼Œè®“ä½ å¯ä»¥ã€Œå°ç…§ä¸Šä¸€å±¤çš„æœ€å¾Œä¸€åˆ—ã€ä¾†ç¹¼çºŒå¾€ä¸Šæ¨æ¼”ï¼Œä¸éœ€è¦ä¸€ç›´åˆ‡æ›å‰å¾Œé ç¢ºèªæ•¸å­—ã€‚</p>

      <h3>åŠé€æ˜ã€Œç–ŠåŠ å±¤ã€é–‹é—œ</h3>
      <p>åœ¨ã€Œåƒç…§è‡ª Lv...ã€é‚£è¡Œæ–‡å­—çš„æ­£ä¸‹æ–¹ï¼Œæœ‰ä¸€å€‹ <strong>ã€Œé¡¯ç¤º Lv {ç•¶å‰å±¤-1}ã€</strong> çš„æ ¸å–æ–¹å¡Š (Checkbox)ã€‚</p>
      <ul>
        <li>
          <strong>æ‰“å‹¾é–‹å•Ÿ</strong>ï¼šåŸæœ¬ä¹¾æ·¨çš„èƒŒæ™¯ä¸Šï¼Œæœƒæµ®ç¾è¨±å¤š<strong>åŠé€æ˜ç¸®å°çš„èˆŠç¯€é»</strong>ï¼Œé€™äº›æ˜¯ç³»çµ±å¹«ä½ æŠŠã€Œä¸Šä¸€é çš„çŸ©é™£ã€ä¾ç…§ç²¾æº–çš„å¹¾ä½•ä½ç½®ç›´æ¥<strong>ç–ŠåŠ </strong>åœ¨ç¾åœ¨çš„ç©ºéš™ä¸­ã€‚
        </li>
        <li>ä½ å¯ä»¥è—‰ç”±é€™å€‹ç–ŠåŠ æ®˜å½±ï¼Œæ›´æ¸…æ¥šåœ°çœ‹è¦‹ã€Œä¸Šä¸€å±¤çš„åœ–å½¢å¦‚ä½•ç™¼å±•ã€ä½ç§»æˆäº†é€™ä¸€å±¤ã€ã€‚</li>
        <li>ç•¶ç•«é¢å¤ªé›œäº‚æ™‚ï¼Œéš¨æ™‚<strong>å–æ¶ˆæ‰“å‹¾</strong>å°±èƒ½ç¬é–“éš±è—å®ƒå€‘ã€‚</li>
      </ul>
      <hr>

      <h2>ğŸ’¾ 4. å­˜æª”ã€åŒ¯å…¥èˆ‡è¼¸å‡ºåœ–ç‰‡</h2>
      <ul>
        <li><strong>å„²å­˜é›²ç«¯ (è‡ªå‹•åŒ–)</strong>ï¼šä½ åœ¨æ ¼å­å…§è¼¸å…¥çš„ä»»ä½•æ±è¥¿ï¼Œåªè¦åœä¸‹å‹•ä½œ 0.6 ç§’ï¼Œå°±æœƒè‡ªå‹•è®Šæˆã€Œé»ƒç‡ˆ å„²å­˜ä¸­...ã€ï¼Œç„¶å¾Œè½‰ç‚ºã€Œç¶ ç‡ˆ å·²é€£ç·šåŒæ­¥ã€å­˜é€²å…±ç·¨è³‡æ–™åº«ï¼Œä¸é ˆæ‰‹å‹•æŒ‰æª”å„²å­˜ã€‚</li>
        <li><strong>ã€ŒğŸ’¾ å‚™ä»½ (JSON)ã€</strong>ï¼šä¸‹è¼‰ä¸€ä»½ <code>.json</code> æª”æ¡ˆåˆ°ä½ å€‹äººçš„é›»è…¦ä¸­å‚™ä»½ï¼Œä»¥é˜²è¬ä¸€ã€‚</li>
        <li><strong>ã€ŒğŸ“‚ åŒ¯å…¥è¦†è“‹ã€</strong>ï¼šä¸Šå‚³ä½ ä¹‹å‰å‚™ä»½å¥½çš„ <code>.json</code>
          æª”æ¡ˆï¼Œé€™æœƒç›´æ¥æŠŠé€™å€‹é€²åº¦<strong>å¼·è¡Œè¦†è“‹</strong>ç•¶å‰çš„ç•«é¢ï¼Œä¸¦ç«‹åˆ»åŒæ­¥çµ¦å…¶ä»–çµ„å“¡ï¼ˆæ“ä½œå‰è«‹èˆ‡çµ„å“¡ç¢ºèªå–”ï¼ï¼‰ã€‚</li>
        <li><strong>ã€ŒğŸ–¼ï¸ åŒ¯å‡ºç•¶å‰ç•«é¢ã€</strong>ï¼šç³»çµ±æœƒå¹«ä½ æŠŠæ•´å€‹æ¨¹ç‹€åœ–è®Šæˆä¸€å¼µè¶…é«˜ç•«è³ªçš„å»èƒŒåœ–ç‰‡ (<code>.png</code>) ä¸‹è¼‰ä¸‹ä¾†ï¼Œå¯«å ±å‘Šã€æŠ•å½±ç‰‡æ™‚éå¸¸å¥½ç”¨ï¼</li>
      </ul>
      <p>ç¥ä½ å€‘æ•¸å­¸å°ˆé¡Œç ”ç©¶é †åˆ©ï¼ğŸš€</p>
    </div>
  </div>

  <!-- ä½¿ç”¨ module å¼•å…¥ Firebase v10 SDK -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-app.js";
    import { initializeFirestore, persistentLocalCache, persistentMultipleTabManager, doc, setDoc, updateDoc, deleteField, onSnapshot } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js";

    // 1. Firebase åˆå§‹åŒ–
    const firebaseConfig = {
      apiKey: "AIzaSyDvHGQqXkdPx496CSDMQ_aU7Q6wbz28D-g",
      authDomain: "doublechess-fe12e.firebaseapp.com",
      projectId: "doublechess-fe12e",
      storageBucket: "doublechess-fe12e.firebasestorage.app",
      messagingSenderId: "1062731143335",
      appId: "1:1062731143335:web:a69ea9a1bc97798f37a382"
    };

    const app = initializeApp(firebaseConfig);
    const db = initializeFirestore(app, {
      localCache: persistentLocalCache({ tabManager: persistentMultipleTabManager() })
    });
    const docRef = doc(db, 'research_data', 'board_state');

    // 2. ç‹€æ…‹è®Šæ•¸
    let tabsList = [];
    let currentIndex = 0;
    let isSyncingFromCloud = false; // é¿å…é›²ç«¯æ›´æ–°æ™‚è§¸ç™¼äºŒæ¬¡ä¸Šå‚³
    let syncTimeout = null;
    let lastSyncState = null; // å„²å­˜æœ€å¾Œä¸€æ¬¡èˆ‡é›²ç«¯åŒæ­¥çš„å®Œæ•´ç‹€æ…‹ï¼Œç”¨ä»¥è¨ˆç®— Delta (å·®ç•°)
    let hasPendingChanges = false; // é˜²å‘†ï¼šæ˜¯å¦æœ‰æ­£åœ¨ç­‰å¾…é€å‡º 0.6 ç§’é˜²æŠ–çš„è®Šæ›´
    const clientId = Math.random().toString(36).substring(2, 15); // éš¨æ©Ÿç”¢ç”Ÿé€™å°è£ç½®çš„ Session ID
    let currentLocks = {}; // ç´€éŒ„å¾é›²ç«¯æŠ“ä¸‹ä¾†çš„æ‰€æœ‰é–å®šç‹€æ…‹
    let lockThrottlers = {}; // ç”¨æ–¼ç¯€æµæœ¬æ©Ÿå¾€é›²ç«¯é€å‡ºé–å®šè¦æ±‚çš„é »ç‡

    // 3. UI ç‡ˆè™Ÿæ§åˆ¶
    function setSyncStatus(status) {
      const dot = document.getElementById('status-dot');
      const text = document.getElementById('status-text');
      dot.className = 'status-dot';
      if (status === 'online') {
        dot.classList.add('online'); text.innerText = 'å·²é€£ç·šåŒæ­¥';
      } else if (status === 'syncing') {
        dot.classList.add('syncing'); text.innerText = 'å„²å­˜ä¸­...';
      } else {
        text.innerText = 'é›¢ç·š / éŒ¯èª¤';
      }
    }

    // 3.5 ç·¨è¼¯é–ç²å–èˆ‡å»¶é•· (Level-based Lock)
    window.acquireOrExtendLock = function (tabId) {
      const now = Date.now();
      const existingLock = currentLocks[tabId];

      // å¦‚æœé€™å€‹åˆ†é è¢«åˆ¥äººé–ä½äº†ï¼Œä¸”é–é‚„æ²’éæœŸï¼Œå‰‡æ‹’çµ•æ“ä½œ
      if (existingLock && existingLock.clientId !== clientId && existingLock.expiresAt > now) {
        return false;
      }

      // å¦‚æœå¯ä»¥å–å¾—é–ï¼Œå…ˆæ¨‚è§€æ›´æ–°æœ¬åœ°ç«¯ç‹€æ…‹ï¼Œè®“ UI ç«‹åˆ»éŸ¿æ‡‰
      currentLocks[tabId] = { clientId, expiresAt: now + 10000 };
      updateLockUI(); // æ›´æ–°è‡ªå·±çš„ UI

      // ç¯€æµï¼šå¦‚æœè·é›¢ä¸Šä¸€æ¬¡é€å‡ºåŒä¸€å€‹åˆ†é çš„é–ä¸åˆ° 2 ç§’ï¼Œå°±ä¸é‡è¤‡ç™¼é€ APIï¼Œé¿å…å¡çˆ† Firestore
      if (!lockThrottlers[tabId] || now - lockThrottlers[tabId] > 2000) {
        lockThrottlers[tabId] = now;
        // æŠŠå–å¾—é–çš„æ“ä½œæ¨ä¸Šé›²ç«¯ (ä¸å½±éŸ¿è³‡æ–™æœ¬èº«ï¼Œæ‰€ä»¥ç›´æ¥ç”¨ updateDoc)
        if (lastSyncState) {
          updateDoc(docRef, { [`locks.${tabId}`]: { clientId, expiresAt: now + 10000 } }).catch(e => console.warn("Acquire lock update failed", e));
        }
      }
      return true;
    };

    // 3.6 æ›´æ–°é–å®š UI (åç°ã€å”¯è®€)
    function updateLockUI() {
      const now = Date.now();
      document.querySelectorAll('.tab-content').forEach(tab => {
        const tabId = tab.id;
        const lock = currentLocks[tabId];
        let isLockedByOther = false;

        if (lock && lock.clientId !== clientId && lock.expiresAt > now) {
          isLockedByOther = true;
        }

        let banner = tab.querySelector('.locked-banner');
        if (isLockedByOther) {
          if (!banner) {
            banner = document.createElement('div');
            banner.className = 'locked-banner';
            banner.innerHTML = 'ğŸ”’ å…¶ä»–ä½¿ç”¨è€…æ­£åœ¨ç·¨è¼¯æ­¤åˆ†é çµæ§‹ï¼Œç›®å‰ç‚ºå”¯è®€ä¿è­·ç‹€æ…‹';
            tab.insertBefore(banner, tab.firstChild);
          }
          tab.classList.add('locked');
          tab.querySelectorAll('input, button').forEach(el => {
            if (!el.dataset.originalDisabled) {
              el.dataset.originalDisabled = el.disabled.toString();
            }
            if (el.type !== 'checkbox') el.disabled = true;
          });
        } else {
          if (banner) banner.remove();
          tab.classList.remove('locked');
          tab.querySelectorAll('input, button').forEach(el => {
            if (el.type !== 'checkbox' && document.activeElement !== el) {
              el.disabled = false;
              if (el.dataset.originalDisabled === "true") el.disabled = true;
            }
          });
        }
      });
    }

    // æ¯ 2 ç§’æª¢æŸ¥ä¸€æ¬¡æœ‰æ²’æœ‰éæœŸçš„é–ï¼Œè‡ªå‹•è§£é™¤
    setInterval(() => {
      updateLockUI();
    }, 2000);

    // 4. æŠ“å–ç•¶å‰æ‰€æœ‰ DOM è³‡æ–™è½‰ç‚º JSON Object (æ”¹ç‚º Map ç‰©ä»¶ä»¥æ”¯æ´ Firebase Delta æ›´æ–°)
    function getAppState() {
      const data = {};
      document.querySelectorAll('.tab-content').forEach(tab => {
        const tabData = { id: tab.id, rows: {} };
        tab.querySelectorAll('.tree-row:not(.ref-row)').forEach(row => {
          const rowData = { r: row.dataset.r, nodes: {} };
          row.querySelectorAll('.node').forEach(node => {
            const nodeInfo = {
              i: node.dataset.i,
              color: node.classList.contains('green') ? 'green' : node.classList.contains('red') ? 'red' : 'white',
              vals: {}
            };
            node.querySelectorAll('input').forEach(input => {
              nodeInfo.vals[input.dataset.pos] = input.value;
            });
            rowData.nodes[nodeInfo.i] = nodeInfo;
          });
          tabData.rows[rowData.r] = rowData;
        });
        data[tab.id] = tabData;
      });
      return data;
    }

    // è¼”åŠ©ï¼šè¨ˆç®—å…©å€‹ JSON çš„æ·±åº¦å·®ç•° (Delta)ï¼Œè½‰ç‚º Firebase dot-notation
    function calculateDiff(oldObj, newObj, prefix = 'state') {
      const diff = {};
      if (oldObj === null || oldObj === undefined) return null;

      function compare(oldVal, newVal, currentPrefix) {
        if (oldVal === newVal) return;

        if (newVal === null || newVal === undefined || typeof newVal !== 'object') {
          diff[currentPrefix] = newVal;
          return;
        }

        if (oldVal === null || typeof oldVal !== 'object') {
          diff[currentPrefix] = newVal;
          return;
        }

        const keys = new Set([...Object.keys(oldVal), ...Object.keys(newVal)]);
        for (const key of keys) {
          if (!(key in oldVal)) {
            diff[`${currentPrefix}.${key}`] = newVal[key];
          } else if (!(key in newVal)) {
            diff[`${currentPrefix}.${key}`] = deleteField();
          } else {
            compare(oldVal[key], newVal[key], `${currentPrefix}.${key}`);
          }
        }
      }

      compare(oldObj, newObj, prefix);
      return diff;
    }

    // 5. å°‡è³‡æ–™æ¨æ’­è‡³ Firebase é›²ç«¯ (Debounce é˜²æŠ– + Delta å·®ç•°æ›´æ–°)
    function scheduleSyncToCloud() {
      if (isSyncingFromCloud) return; // å¦‚æœæ­£åœ¨æ¥æ”¶é›²ç«¯è³‡æ–™ï¼Œä¸åå‘æ¨æ’­

      hasPendingChanges = true; // é–ä½ï¼Œå‘Šè¨´ç³»çµ±ç›®å‰æœ¬æ©Ÿæœ‰æœ€æ–°è‰ç¨¿
      setSyncStatus('syncing');
      clearTimeout(syncTimeout);
      syncTimeout = setTimeout(async () => {
        try {
          const currentState = getAppState();

          if (!lastSyncState) {
            await setDoc(docRef, { state: currentState, timestamp: new Date().toISOString() });
          } else {
            const diff = calculateDiff(lastSyncState, currentState, 'state');

            if (diff === null) {
              await setDoc(docRef, { state: currentState, timestamp: new Date().toISOString() });
            } else if (Object.keys(diff).length > 0) {
              diff['timestamp'] = new Date().toISOString();
              await updateDoc(docRef, diff);
            }
          }

          // é é˜²æ€§æ›´æ–°æœ€å¾Œç‹€æ…‹
          lastSyncState = currentState;
          setSyncStatus('online');
        } catch (error) {
          console.error("Firebase å„²å­˜å¤±æ•—:", error);
          setSyncStatus('error');
        } finally {
          hasPendingChanges = false; // é€å‡ºå®Œç•¢ï¼Œçµç®—è§£é–
        }
      }, 600); // åœæ­¢æ‰“å­—/æ“ä½œ 0.6 ç§’å¾Œè‡ªå‹•å„²å­˜
    }

    // 6. æ¥æ”¶ Firebase é›²ç«¯è³‡æ–™ä¸¦æ›´æ–° UI (é˜²æ¸¸æ¨™è·³å‹•)
    function applyDataToUI(data) {
      if (!data) return;
      lastSyncState = JSON.parse(JSON.stringify(data)); // ç´€éŒ„é›²ç«¯æœ€æ–°çš„å®Œæ•´ç‹€æ…‹ï¼Œä¾›å¾ŒçºŒæ¯”å°
      isSyncingFromCloud = true; // é–ä½ï¼Œé¿å…è§¸ç™¼ scheduleSyncToCloud

      // å°‡ Map è½‰æˆæœ‰æ’åºçš„ Array ä»¥ä¿è­‰é †åº
      // å®¹éŒ¯æ©Ÿåˆ¶ï¼šå¦‚æœ data æ˜¯èˆŠç‰ˆ Array (æˆ–è€…èˆŠå‚™ä»½æª”)ï¼Œç›´æ¥ä½¿ç”¨ï¼Œå¦å‰‡è½‰ Object.values æ’åº
      let dataArray = [];
      if (Array.isArray(data)) {
        dataArray = data;
      } else {
        dataArray = Object.values(data).sort((a, b) => {
          const numA = parseInt(a.id.split('_')[1] || '0');
          const numB = parseInt(b.id.split('_')[1] || '0');
          return numA - numB;
        });
      }

      // a. å»ºç«‹ç¼ºå°‘çš„ Tab
      dataArray.forEach(tabData => {
        if (!tabsList.includes(tabData.id)) window.createTab(tabData.id, false);
      });

      // b. æ›´æ–°æ¯ä¸€åˆ—èˆ‡ç¯€é»
      dataArray.forEach(tabData => {
        const container = document.getElementById(`tree-${tabData.id}`);
        if (!container) return;

        // å®¹éŒ¯ï¼šè®“ rows ä¹Ÿæ”¯æ´ Map æˆ– Array
        let rowsArray = [];
        if (tabData.rows) {
          if (Array.isArray(tabData.rows)) {
            rowsArray = tabData.rows;
          } else {
            rowsArray = Object.values(tabData.rows).sort((a, b) => parseInt(a.r) - parseInt(b.r));
          }
        }

        // è£œè¶³åˆ—æ•¸
        let currentRows = container.querySelectorAll('.tree-row:not(.ref-row)');
        while (currentRows.length < rowsArray.length) {
          window.addRow(tabData.id, null, false);
          currentRows = container.querySelectorAll('.tree-row:not(.ref-row)');
        }
        // åˆªé™¤å¤šé¤˜çš„åˆ—æ•¸
        while (currentRows.length > rowsArray.length) {
          container.removeChild(currentRows[currentRows.length - 1]);
          currentRows = container.querySelectorAll('.tree-row:not(.ref-row)');
        }

        // c. æ›´æ–°å…§å®¹ (é¿é–‹ç›®å‰ focus çš„è¼¸å…¥æ¡†)
        rowsArray.forEach(rowData => {
          let nodesArray = [];
          if (rowData.nodes) {
            if (Array.isArray(rowData.nodes)) {
              nodesArray = rowData.nodes;
            } else {
              nodesArray = Object.values(rowData.nodes);
            }
          }

          const rowDiv = container.querySelector(`.tree-row:not(.ref-row)[data-r="${rowData.r}"]`);
          if (rowDiv) {
            nodesArray.forEach(nodeData => {
              const node = rowDiv.querySelector(`.node[data-i="${nodeData.i}"]`);
              if (node) {
                if (!node.classList.contains(nodeData.color)) {
                  node.className = `node ${nodeData.color}`;
                }
                for (const pos in nodeData.vals) {
                  const input = node.querySelector(`input[data-pos="${pos}"]`);
                  // é—œéµï¼šå¦‚æœæˆ‘æ­£åœ¨æ‰“å­—ï¼Œä¸è¦ç”¨é›²ç«¯çš„èˆŠè³‡æ–™è¦†è“‹æˆ‘çš„æ¸¸æ¨™
                  if (input && input !== document.activeElement) {
                    if (input.value !== nodeData.vals[pos]) {
                      input.value = nodeData.vals[pos];
                      input.style.width = Math.max(3, input.value.length + 1) + 'ch';
                    }
                  }
                }
              }
            });
          }
        });

        updateReferenceRow(tabData.id);
        drawArrows(tabData.id);
        drawExperimentalNodes(tabData.id);
      });

      if (tabsList.length > 0 && document.querySelectorAll('.tab-content.active').length === 0) {
        window.switchTab(0);
      }

      isSyncingFromCloud = false; // è§£é™¤é–å®š
    }

    // ================= æ ¸å¿ƒé‚è¼¯å€å¡Š =================

    window.createTab = function (tabIdName = null, triggerSync = true) {
      const tabId = tabIdName || `Lv_${tabsList.length}`;
      if (!tabsList.includes(tabId)) {
        tabsList.push(tabId);
      }

      const tabContent = document.createElement('div');
      tabContent.id = tabId; tabContent.className = 'tab-content';

      const controlsDiv = document.createElement('div');
      controlsDiv.style.textAlign = 'center'; controlsDiv.style.marginBottom = '15px';

      const addRowBtn = document.createElement('button');
      addRowBtn.className = 'btn'; addRowBtn.style.marginRight = '10px';
      addRowBtn.innerText = 'â¬†ï¸ å¾€ä¸Šæ–°å¢ä¸€åˆ— Node (+2)';
      addRowBtn.onclick = () => {
        if (!window.acquireOrExtendLock(tabId)) return;
        window.addRow(tabId);
        drawArrows(tabId);
      };

      const undoRowBtn = document.createElement('button');
      undoRowBtn.className = 'btn undo'; undoRowBtn.innerText = 'â¬‡ï¸ åˆªé™¤æœ€ä¸Šåˆ— (é‚„åŸ)';
      undoRowBtn.onclick = () => {
        if (!window.acquireOrExtendLock(tabId)) return;
        window.removeRow(tabId);
      };

      controlsDiv.appendChild(addRowBtn); controlsDiv.appendChild(undoRowBtn);

      const treeContainer = document.createElement('div');
      treeContainer.className = 'tree-container'; treeContainer.id = `tree-${tabId}`;

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('class', 'tree-svg');
      svg.innerHTML = `<defs><marker id="arrow-${tabId}" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="5" markerHeight="5" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#a0aec0" /></marker></defs>`;
      treeContainer.appendChild(svg);

      tabContent.appendChild(controlsDiv); tabContent.appendChild(treeContainer);
      document.getElementById('tab-contents').appendChild(tabContent);

      if (!tabIdName) {
        window.addRow(tabId, null, false);
        window.switchTab(tabsList.length - 1);
      }

      if (triggerSync) scheduleSyncToCloud();
      return tabId;
    };

    window.switchTab = function (index) {
      if (index < 0 || index >= tabsList.length) return;
      currentIndex = index;
      const tabId = tabsList[currentIndex];

      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.toggle('active', content.id === tabId);
      });

      document.getElementById('current-tab-label').innerText = tabId.replace('_', ' ');
      document.getElementById('prev-btn').disabled = (currentIndex === 0);
      document.getElementById('next-btn').disabled = (currentIndex === tabsList.length - 1);

      updateReferenceRow(tabId);
      setTimeout(() => {
        drawArrows(tabId);
        drawExperimentalNodes(tabId);
      }, 50);
    };

    window.prevTab = function () { window.switchTab(currentIndex - 1); };
    window.nextTab = function () { window.switchTab(currentIndex + 1); };

    function updateReferenceRow(tabId) {
      const nMatch = tabId.match(/Lv_(\d+)/);
      if (!nMatch) return;
      const n = parseInt(nMatch[1]);
      if (n === 0) return;

      const sourceN = n % 2 !== 0 ? n - 1 : n - 2;
      const sourceTabId = `Lv_${sourceN}`;
      const sourceContainer = document.getElementById(`tree-${sourceTabId}`);
      if (!sourceContainer) return;

      const sourceRows = Array.from(sourceContainer.querySelectorAll('.tree-row:not(.ref-row)'));
      if (sourceRows.length === 0) return;
      const lastSourceRow = sourceRows.reduce((prev, current) => parseInt(current.dataset.r) > parseInt(prev.dataset.r) ? current : prev);

      const container = document.getElementById(`tree-${tabId}`);
      if (!container) return;

      const oldRefRow = container.querySelector('.ref-row');
      if (oldRefRow) oldRefRow.remove();

      const refRow = document.createElement('div');
      refRow.className = 'tree-row ref-row';

      const label = document.createElement('div');
      label.className = 'ref-label';
      label.innerHTML = `<span>[ åƒç…§è‡ª Lv ${sourceN} çš„æœ€å¾Œä¸€åˆ— ]</span>`;

      if (n >= 4) {
        const toggleLabel = document.createElement('label');
        toggleLabel.style.display = 'flex';
        toggleLabel.style.alignItems = 'center';
        toggleLabel.style.gap = '5px';
        toggleLabel.style.cursor = 'pointer';
        toggleLabel.style.fontSize = '18px';
        toggleLabel.style.fontWeight = 'bold';
        toggleLabel.style.color = '#4a5568';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.style.width = '20px';
        checkbox.style.height = '20px';
        checkbox.checked = !document.body.classList.contains('hide-ref-layer');
        checkbox.addEventListener('change', function () {
          if (this.checked) document.body.classList.remove('hide-ref-layer');
          else document.body.classList.add('hide-ref-layer');
        });

        toggleLabel.appendChild(checkbox);
        toggleLabel.appendChild(document.createTextNode(`é¡¯ç¤º Lv ${n - 1}`));
        label.appendChild(toggleLabel);
      }

      refRow.appendChild(label);

      const nodes = lastSourceRow.querySelectorAll('.node');
      nodes.forEach(sourceNode => {
        const newNode = document.createElement('div');
        const colorClass = sourceNode.classList.contains('green') ? 'green' : sourceNode.classList.contains('red') ? 'red' : 'white';
        newNode.className = `node ref-node ${colorClass}`;

        ['a', 'b', 'c', 'd'].forEach(pos => {
          const sourceInput = sourceNode.querySelector(`input[data-pos="${pos}"]`);
          const input = document.createElement('input');
          input.type = 'text'; input.dataset.pos = pos;
          input.value = sourceInput ? sourceInput.value : '';
          input.readOnly = true;
          input.style.width = sourceInput ? sourceInput.style.width : '3ch';
          newNode.appendChild(input);
        });
        refRow.appendChild(newNode);
      });

      container.appendChild(refRow);
    }

    function drawExperimentalNodes(tabId) {
      const nMatch = tabId.match(/Lv_(\d+)/);
      if (!nMatch) return;
      const n = parseInt(nMatch[1]);
      if (n < 4) return; // å¾ Lv 4 é–‹å§‹

      const container = document.getElementById(`tree-${tabId}`);
      if (!container) return;

      // æ¸…é™¤èˆŠçš„ç–ŠåŠ ç¯€é»
      container.querySelectorAll('.exp-node').forEach(n => n.remove());

      const sourceTabId = `Lv_${n - 1}`;
      const sourceContainer = document.getElementById(`tree-${sourceTabId}`);
      if (!sourceContainer) return; // å¦‚æœä¸Šä¸€å±¤é‚„æ²’å»ºç«‹å‰‡è·³é

      const sourceRows = Array.from(sourceContainer.querySelectorAll('.tree-row:not(.ref-row)'));
      if (sourceRows.length === 0) return;

      const containerRect = container.getBoundingClientRect();

      // æ±ºå®šè¦æå–çš„åƒç…§å±¤åˆ— (r)
      let rowsToExtract = [];
      if (n % 2 !== 0) {
        // nç‚ºå¥‡æ•¸æ™‚ï¼Œåƒç…§å±¤(å¶æ•¸å±¤)åªé¡¯ç¤ºé™¤äº†ç¬¬ä¸€åˆ—(r=0)å’Œæœ€å¾Œä¸€åˆ—ä»¥å¤–çš„ç¯€é»
        rowsToExtract = sourceRows.filter((row, idx) => idx !== 0 && idx !== sourceRows.length - 1);
      } else {
        // nç‚ºå¶æ•¸æ™‚ï¼Œåƒç…§å±¤(å¥‡æ•¸å±¤)åªé¡¯ç¤ºé™¤äº†ç¬¬ä¸€åˆ—(r=0)ä»¥å¤–çš„ç¯€é»
        rowsToExtract = sourceRows.filter((row, idx) => idx !== 0);
      }

      rowsToExtract.forEach(sourceRow => {
        const r_prev = parseInt(sourceRow.dataset.r);
        const sourceNodes = sourceRow.querySelectorAll('.node');

        sourceNodes.forEach(sourceNode => {
          const i_prev = parseInt(sourceNode.dataset.i);

          // è¦å‰‡ 1: lv(n-1)çš„ç¯€é»èˆ‡lv(n)çš„ç¯€é»ç”±ç¬¬ä¸€åˆ—é–‹å§‹å°é½Š
          // æ‰€ä»¥åº§æ¨™ç›´æ¥å°æ‡‰åˆ°è©²å±¤çš„ç›¸åŒ r èˆ‡ i
          const node1 = container.querySelector(`.tree-row[data-r="${r_prev}"] .node[data-i="${i_prev}"]`);

          if (node1) {
            const rect1 = node1.getBoundingClientRect();

            // å–å¾— Lv(n) è©²ç¯€é»çš„ä¸­å¿ƒé»
            const baseX = (rect1.left + rect1.right) / 2 - containerRect.left + container.scrollLeft;
            const baseY = (rect1.top + rect1.bottom) / 2 - containerRect.top + container.scrollTop;

            // X è»¸æ°´å¹³åç§»å–æ¶ˆ (0px)
            const xOffset = 0;
            // Y è»¸å‚ç›´åç§»åˆ°é–“éš™ä¸­å¤®ï¼š(ç¯€é»é«˜åº¦ + å‚ç›´gap 80px) / 2
            const yOffset = (rect1.height + 80) / 2;

            const centerX = baseX + xOffset;
            const centerY = baseY - yOffset; // Y åº§æ¨™å¾€ä¸Šæ˜¯æ¸›

            // å»ºç«‹ç–ŠåŠ ç¯€é» (Ghost Node)
            const expNode = document.createElement('div');
            const colorClass = sourceNode.classList.contains('green') ? 'green' : sourceNode.classList.contains('red') ? 'red' : 'white';
            expNode.className = `node exp-node ${colorClass}`;

            // è¨­å®šæ¨£å¼èˆ‡ä½ç§»
            expNode.style.position = 'absolute';
            expNode.style.left = `${centerX}px`;
            expNode.style.top = `${centerY}px`;
            expNode.style.transform = `translate(-50%, -50%) scale(0.85)`;
            expNode.style.zIndex = '1'; // ç¢ºä¿åœ¨èƒŒæ™¯ä½†é«˜æ–¼ç·šæ¢
            expNode.style.opacity = '0.5'; // åŠé€æ˜åœ–å±¤
            expNode.style.pointerEvents = 'none'; // ç„¡æ³•é»æ“Š

            ['a', 'b', 'c', 'd'].forEach(pos => {
              const sourceInput = sourceNode.querySelector(`input[data-pos="${pos}"]`);
              const input = document.createElement('input');
              input.type = 'text'; input.dataset.pos = pos;
              input.value = sourceInput ? sourceInput.value : '';
              input.readOnly = true;
              input.style.width = sourceInput ? sourceInput.style.width : '3ch';
              input.style.pointerEvents = 'none';
              input.style.background = 'transparent';
              input.style.borderColor = 'transparent';
              expNode.appendChild(input);
            });

            container.appendChild(expNode);
          }
        });
      });
    }

    window.addRow = function (tabId, r = null, triggerSync = true) {
      const container = document.getElementById(`tree-${tabId}`);
      const rowsCount = container.querySelectorAll('.tree-row:not(.ref-row)').length;
      const rowIndex = r !== null ? r : rowsCount;

      const rowDiv = document.createElement('div');
      rowDiv.className = 'tree-row'; rowDiv.dataset.r = rowIndex;

      const numNodes = 2 * rowIndex + 1;
      for (let i = 0; i < numNodes; i++) {
        rowDiv.appendChild(createNode(rowIndex, i, tabId));
      }

      const refRow = container.querySelector('.ref-row');
      if (refRow) container.insertBefore(rowDiv, refRow);
      else container.appendChild(rowDiv);

      drawExperimentalNodes(tabId); // é‡ç¹ªç–ŠåŠ å±¤
      if (triggerSync) scheduleSyncToCloud();
      return rowDiv;
    };

    window.removeRow = function (tabId) {
      const container = document.getElementById(`tree-${tabId}`);
      if (!container) return;
      const rows = container.querySelectorAll('.tree-row:not(.ref-row)');

      if (rows.length <= 1) {
        alert("å·²ç¶“æ˜¯ç¬¬ä¸€åˆ—åŸºç¤ç¯€é»ï¼Œç„¡æ³•å†é‚„åŸäº†ï¼"); return;
      }
      container.removeChild(rows[rows.length - 1]);
      drawArrows(tabId);
      drawExperimentalNodes(tabId); // é‡ç¹ªç–ŠåŠ å±¤
      scheduleSyncToCloud();
    };

    function createNode(r, i, tabId) {
      const node = document.createElement('div');
      node.className = 'node white'; node.dataset.i = i;

      const picker = document.createElement('div');
      picker.className = 'color-picker';
      picker.innerHTML = `
        <button class="btn-color btn-green" onclick="window.setNodeColor(event, this, 'green', '${tabId}')">O</button>
        <button class="btn-color btn-red" onclick="window.setNodeColor(event, this, 'red', '${tabId}')">X</button>
    `;
      node.appendChild(picker);

      ['a', 'b', 'c', 'd'].forEach(pos => {
        const input = document.createElement('input');
        input.type = 'text'; input.dataset.pos = pos;

        input.onfocus = () => {
          if (!window.acquireOrExtendLock(tabId)) {
            input.blur();
          }
        };

        input.oninput = () => {
          if (!window.acquireOrExtendLock(tabId)) return;
          input.style.width = Math.max(3, input.value.length + 1) + 'ch';
          syncSymmetricNode(input, r, i);
          setTimeout(() => drawArrows(tabId), 50);
          scheduleSyncToCloud(); // è¼¸å…¥æ™‚è§¸ç™¼é›²ç«¯åŒæ­¥
        };

        input.onkeydown = (e) => handleArrowKeys(e, input);
        node.appendChild(input);
      });
      return node;
    }

    window.setNodeColor = function (event, btnElement, colorClass, tabId) {
      event.stopPropagation();
      if (!window.acquireOrExtendLock(tabId)) return;
      const node = btnElement.closest('.node');
      if (node.classList.contains(colorClass)) node.className = 'node white';
      else node.className = `node ${colorClass}`;
      scheduleSyncToCloud();
    };

    function syncSymmetricNode(input, r, i) {
      const val = input.value; const pos = input.dataset.pos;
      const targetI = 2 * r - i;
      if (targetI === i) return;

      const rowDiv = input.closest('.tree-row');
      const targetNode = rowDiv.querySelector(`.node[data-i="${targetI}"]`);
      if (!targetNode) return;

      let targetPos = pos === 'a' ? 'b' : pos === 'b' ? 'a' : pos === 'c' ? 'd' : 'c';
      const targetInput = targetNode.querySelector(`input[data-pos="${targetPos}"]`);
      if (targetInput) {
        targetInput.value = val;
        targetInput.style.width = Math.max(3, val.length + 1) + 'ch';
      }
    }

    function handleArrowKeys(e, input) {
      const node = input.closest('.node'); const rowDiv = input.closest('.tree-row');
      const pos = input.dataset.pos; const i = parseInt(node.dataset.i);

      const focusPos = (targetNode, p) => {
        if (targetNode) {
          const target = targetNode.querySelector(`input[data-pos="${p}"]`);
          if (target && !target.readOnly) { target.focus(); e.preventDefault(); }
        }
      };

      if (e.key === 'ArrowUp') {
        if (pos === 'b') focusPos(node, 'a');
        if (pos === 'd') focusPos(node, 'c');
      } else if (e.key === 'ArrowDown') {
        if (pos === 'a') focusPos(node, 'b');
        if (pos === 'c') focusPos(node, 'd');
      } else if (e.key === 'ArrowLeft') {
        if (input.selectionStart === 0) {
          if (pos === 'c') focusPos(node, 'a');
          else if (pos === 'd') focusPos(node, 'b');
          else if (pos === 'a' || pos === 'b') focusPos(rowDiv.querySelector(`.node[data-i="${i - 1}"]`), pos === 'a' ? 'c' : 'd');
        }
      } else if (e.key === 'ArrowRight') {
        if (input.selectionEnd === input.value.length) {
          if (pos === 'a') focusPos(node, 'c');
          else if (pos === 'b') focusPos(node, 'd');
          else if (pos === 'c' || pos === 'd') focusPos(rowDiv.querySelector(`.node[data-i="${i + 1}"]`), pos === 'c' ? 'a' : 'b');
        }
      }
    }

    function drawArrows(tabId) {
      const container = document.getElementById(`tree-${tabId}`);
      if (!container) return;
      const svg = container.querySelector('svg.tree-svg');
      if (!svg) return;

      svg.innerHTML = svg.querySelector('defs').outerHTML;
      svg.style.width = container.scrollWidth + 'px';
      svg.style.height = container.scrollHeight + 'px';

      const containerRect = container.getBoundingClientRect();
      const rows = container.querySelectorAll('.tree-row:not(.ref-row)');

      for (let r = 0; r < rows.length; r++) {
        const currentRow = container.querySelector(`.tree-row:not(.ref-row)[data-r="${r}"]`);
        const nextRow = container.querySelector(`.tree-row:not(.ref-row)[data-r="${r + 1}"]`);
        if (!currentRow) continue;

        const numNodes = 2 * r + 1;
        for (let i = 0; i < numNodes; i++) {
          const fromNode = currentRow.querySelector(`.node[data-i="${i}"]`);
          if (!fromNode) continue;

          const rectFrom = fromNode.getBoundingClientRect();
          const drawLine = (startX, startY, endX, endY) => {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startX); line.setAttribute('y1', startY);
            line.setAttribute('x2', endX); line.setAttribute('y2', endY);
            line.setAttribute('stroke', '#a0aec0'); line.setAttribute('stroke-width', '2');
            line.setAttribute('marker-end', `url(#arrow-${tabId})`);
            svg.appendChild(line);
          };

          if (nextRow) {
            const upNode = nextRow.querySelector(`.node[data-i="${i + 1}"]`);
            if (upNode) {
              const rectTo = upNode.getBoundingClientRect();
              const startX = rectFrom.left + rectFrom.width / 2 - containerRect.left + container.scrollLeft;
              const startY = rectFrom.top - containerRect.top + container.scrollTop;
              const endX = rectTo.left + rectTo.width / 2 - containerRect.left + container.scrollLeft;
              const endY = rectTo.bottom - containerRect.top + container.scrollTop;
              drawLine(startX, startY, endX, endY + 2);
            }
          }

          const drawHorizontal = (toNode, direction) => {
            if (!toNode) return;
            const rectTo = toNode.getBoundingClientRect();
            let startX, startY, endX, endY;
            const offsetGap = document.body.classList.contains('compact-mode') ? 2 : 8;
            if (direction === 'left') {
              startX = rectFrom.left - containerRect.left + container.scrollLeft;
              startY = rectFrom.top + rectFrom.height / 2 - containerRect.top + container.scrollTop;
              endX = rectTo.right - containerRect.left + container.scrollLeft;
              endY = rectTo.top + rectTo.height / 2 - containerRect.top + container.scrollTop;
              drawLine(startX, startY, endX + offsetGap, endY);
            } else {
              startX = rectFrom.right - containerRect.left + container.scrollLeft;
              startY = rectFrom.top + rectFrom.height / 2 - containerRect.top + container.scrollTop;
              endX = rectTo.left - containerRect.left + container.scrollLeft;
              endY = rectTo.top + rectTo.height / 2 - containerRect.top + container.scrollTop;
              drawLine(startX, startY, endX - offsetGap, endY);
            }
          };

          if (i === r) {
            drawHorizontal(currentRow.querySelector(`.node[data-i="${i - 1}"]`), 'left');
            drawHorizontal(currentRow.querySelector(`.node[data-i="${i + 1}"]`), 'right');
          } else if (i < r) {
            drawHorizontal(currentRow.querySelector(`.node[data-i="${i - 1}"]`), 'left');
          } else if (i > r) {
            drawHorizontal(currentRow.querySelector(`.node[data-i="${i + 1}"]`), 'right');
          }
        }
      }

      // è™•ç†æœ€å¾Œä¸€åˆ—é€£ç·šåˆ°åƒç…§åˆ— (Reference Row)
      const isCompact = document.body.classList.contains('compact-mode');
      const refRow = container.querySelector('.ref-row');
      if (!isCompact && refRow && rows.length > 0) {
        const lastRow = rows[rows.length - 1];
        const r = parseInt(lastRow.dataset.r);
        const numNodes = 2 * r + 1;
        const refNodes = Array.from(refRow.querySelectorAll('.node'));
        const refR = (refNodes.length - 1) / 2;

        for (let i = 0; i < numNodes; i++) {
          const fromNode = lastRow.querySelector(`.node[data-i="${i}"]`);
          if (!fromNode) continue;

          const rectFrom = fromNode.getBoundingClientRect();
          const drawLine = (startX, startY, endX, endY) => {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startX); line.setAttribute('y1', startY);
            line.setAttribute('x2', endX); line.setAttribute('y2', endY);
            line.setAttribute('stroke', '#a0aec0'); line.setAttribute('stroke-width', '2');
            line.setAttribute('marker-end', `url(#arrow-${tabId})`);
            svg.appendChild(line);
          };

          const offset = i - r; // èˆ‡ä¸­è»¸çš„è·é›¢ (- for left, + for right)

          // æ‰¾å°‹å°æ‡‰çš„ target ç¯€é» (æ­£ä¸Šæ–¹)
          const targetI_up = refR + offset;
          if (targetI_up >= 0 && targetI_up < refNodes.length) {
            const upNode = refNodes[targetI_up];
            if (upNode) {
              const rectTo = upNode.getBoundingClientRect();
              const startX = rectFrom.left + rectFrom.width / 2 - containerRect.left + container.scrollLeft;
              const startY = rectFrom.top - containerRect.top + container.scrollTop;
              const endX = rectTo.left + rectTo.width / 2 - containerRect.left + container.scrollLeft;
              const endY = rectTo.bottom - containerRect.top + container.scrollTop;
              drawLine(startX, startY, endX, endY + 4);
            }
          }

          // æ‰¾å°‹å°æ‡‰çš„ target ç¯€é» (å·¦å‰æ–¹/å³å‰æ–¹)
          if (offset !== 0) { // éä¸­è»¸
            // å°æ–¼å·¦å´ç¯€é»ï¼Œå³å‰æ–¹ä»£è¡¨è·é›¢ä¸­è»¸è¿‘ 1 æ ¼ (+1)
            // å°æ–¼å³å´ç¯€é»ï¼Œå·¦å‰æ–¹ä»£è¡¨è·é›¢ä¸­è»¸è¿‘ 1 æ ¼ (-1)
            const diagOffset = offset > 0 ? offset - 1 : offset + 1;
            const targetI_diag = refR + diagOffset;

            if (targetI_diag >= 0 && targetI_diag < refNodes.length) {
              const diagNode = refNodes[targetI_diag];
              if (diagNode) {
                const rectTo = diagNode.getBoundingClientRect();
                const startX = rectFrom.left + rectFrom.width / 2 - containerRect.left + container.scrollLeft;
                const startY = rectFrom.top - containerRect.top + container.scrollTop;
                let endX = rectTo.left + rectTo.width / 2 - containerRect.left + container.scrollLeft;
                const endY = rectTo.bottom - containerRect.top + container.scrollTop;

                // ç‚ºäº†é¿å…èˆ‡æ­£ä¸‹æ–¹ä¸Šä¾†çš„ç®­é ­é‡ç–Šï¼Œå¾®èª¿æ–œå‘ç®­é ­çš„å°¾ç«¯ä½ç½®
                if (offset < 0) {
                  // å·¦å´ç¯€é»å¾€å³ä¸Šæ–¹é€£ï¼šç®­é ­å°¾ç«¯ç•¥å¾€å·¦ç§»
                  endX -= 12;
                } else if (offset > 0) {
                  // å³å´ç¯€é»å¾€å·¦ä¸Šæ–¹é€£ï¼šç®­é ­å°¾ç«¯ç•¥å¾€å³ç§»
                  endX += 12;
                }

                drawLine(startX, startY, endX, endY + 4);
              }
            }
          } else {
            // é‡å°ä¸­è»¸ç¯€é» (offset == 0) é€£æ¥åˆ°æ­£ä¸Šæ–¹ï¼Œå·²ç¶“ç”±ä¸Šé¢ targetI_up è™•ç†éäº†
          }
        }
      }
    }

    window.addEventListener('resize', () => {
      const activeTab = document.querySelector('.tab-content.active');
      if (activeTab) {
        drawArrows(activeTab.id);
        if (typeof drawExperimentalNodes === 'function') drawExperimentalNodes(activeTab.id);
      }
    });

    window.toggleCompactMode = function (e) {
      if (e.target.checked) {
        document.body.classList.add('compact-mode');
      } else {
        document.body.classList.remove('compact-mode');
      }
      setTimeout(() => {
        const activeTab = document.querySelector('.tab-content.active');
        if (activeTab) {
          drawArrows(activeTab.id);
          if (typeof drawExperimentalNodes === 'function') drawExperimentalNodes(activeTab.id);
        }
      }, 50);
    };

    // ================= è¼¸å‡ºèˆ‡æœ¬åœ°å‚™ä»½ =================
    window.exportToImage = function () {
      const activeTabElement = document.querySelector('.tab-content.active');
      if (!activeTabElement) return;
      const activeTab = activeTabElement.querySelector('.tree-container');
      if (!activeTab) return;

      const tabId = activeTabElement.id; // e.g., 'Lv_0'
      const pickers = activeTab.querySelectorAll('.color-picker');
      pickers.forEach(p => p.style.display = 'none');

      html2canvas(activeTab, { backgroundColor: "#ffffff", scale: 2 }).then(canvas => {
        const link = document.createElement('a');
        const dateStr = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        link.download = `${tabId}_${dateStr}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
        pickers.forEach(p => p.style.display = '');
      });
    };

    window.saveData = function () {
      const data = getAppState();
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `å°ˆé¡Œç´€éŒ„_${new Date().toISOString().slice(0, 10)}.json`;
      link.click();
    };

    window.loadData = function (event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const data = JSON.parse(e.target.result);
          applyDataToUI(data);
          scheduleSyncToCloud(); // åŒ¯å…¥æˆåŠŸå¾Œï¼Œå¼·åˆ¶æ¨æ’­çµ¦å…¶ä»–çµ„å“¡
          alert("é€²åº¦åŒ¯å…¥æˆåŠŸï¼å·²åŒæ­¥è‡³é›²ç«¯ã€‚");
        } catch (err) { alert("æª”æ¡ˆæ ¼å¼éŒ¯èª¤æˆ–ææ¯€ã€‚"); }
      };
      reader.readAsText(file);
      event.target.value = "";
    };

    // é»æ“Š Modal å¤–éƒ¨é—œé–‰
    window.onclick = function (event) {
      const helpModal = document.getElementById('helpModal');
      if (event.target === helpModal) {
        helpModal.style.display = "none";
      }
    }
    // ================= åˆå§‹åŒ–é€£ç·šç›£è½ =================
    setSyncStatus('syncing');

    onSnapshot(docRef, (docSnap) => {
      if (docSnap.exists()) {
        const dbData = docSnap.data();

        // æ›´æ–°é–å®šç‹€æ…‹
        if (dbData.locks) {
          currentLocks = dbData.locks;
          updateLockUI();
        }

        // æ ¸å¿ƒè³‡æ–™ç¹ªè£½
        if (dbData.state) {
          if (!hasPendingChanges) {
            applyDataToUI(dbData.state);
          } else {
            // èƒŒæ™¯åŒæ­¥ lastSyncState ä»¥ä¾› Delta æ¯”å°ä½¿ç”¨ï¼Œä½†ä¸è¦†å¯« DOM
            lastSyncState = JSON.parse(JSON.stringify(dbData.state));
          }
        }
        setSyncStatus('online');
      } else {
        // ç¬¬ä¸€å€‹é–‹å•Ÿé€™å€‹å°ˆæ¡ˆçš„äººï¼šå»ºç«‹ç©ºç™½çš„ç¬¬ä¸€é ï¼Œä¸¦æ¨æ’­çµ¦é›²ç«¯
        if (tabsList.length === 0) {
          window.createTab();
        }
      }
    }, (error) => {
      console.error("Firestore ç›£è½å¤±æ•— (è«‹ç¢ºèª Rules æ˜¯å¦ç‚ºå…è¨±è®€å¯«):", error);
      setSyncStatus('error');
      if (tabsList.length === 0) window.createTab(null, false); // é›¢ç·šç‹€æ…‹ä¸‹è‡³å°‘èƒ½æœ¬æ©Ÿé‹ä½œ
    });

  </script>
</body>

</html>