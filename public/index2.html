<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4å…ƒæ•¸ Node ç´€éŒ„è¡¨ 2 - é›²ç«¯å…±ç·¨ç‰ˆ</title>
  <!-- å¼•å…¥ html2canvas ç•«å¸ƒè½‰æ›å¥—ä»¶ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f4f4f9;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      height: 100vh;
      box-sizing: border-box;
    }

    /* ä¸Šæ–¹æ§åˆ¶åˆ—èˆ‡åˆ†é å™¨ */
    .header-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      z-index: 10;
    }

    .pagination {
      display: flex;
      align-items: center;
      gap: 15px;
      background: #edf2f7;
      padding: 4px 12px;
      border-radius: 6px;
      border: 1px solid #cbd5e0;
      flex-grow: 1;
      justify-content: center;
    }

    .page-btn {
      cursor: pointer;
      border: none;
      background: #cbd5e0;
      border-radius: 4px;
      padding: 6px 16px;
      font-weight: bold;
      font-size: 14px;
      color: #2d3748;
      transition: 0.2s;
    }

    .page-btn:hover:not(:disabled) {
      background: #a0aec0;
    }

    .page-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .page-label {
      font-weight: bold;
      font-size: 16px;
      color: #2d3748;
      min-width: 80px;
      text-align: center;
    }

    .btn {
      padding: 8px 16px;
      cursor: pointer;
      border: none;
      background: #3182ce;
      color: white;
      border-radius: 6px;
      font-weight: bold;
      transition: 0.2s;
    }

    .btn:hover {
      background: #2b6cb0;
    }

    .btn.export {
      background: #38a169;
    }

    .btn.export:hover {
      background: #2f855a;
    }

    .btn.save {
      background: #d69e2e;
    }

    .btn.save:hover {
      background: #b7791f;
    }

    .btn.load {
      background: #805ad5;
    }

    .btn.load:hover {
      background: #6b46c1;
    }

    .btn.undo {
      background: #e53e3e;
    }

    .btn.undo:hover {
      background: #c53030;
    }

    /* åŒæ­¥ç‹€æ…‹ç‡ˆè™Ÿ */
    .sync-status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: bold;
      font-size: 14px;
      color: #4a5568;
      padding: 4px 10px;
      border-radius: 20px;
      background: #e2e8f0;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #a0aec0;
    }

    .status-dot.online {
      background: #48bb78;
      box-shadow: 0 0 5px #48bb78;
    }

    .status-dot.syncing {
      background: #ecc94b;
      box-shadow: 0 0 5px #ecc94b;
    }

    #fileInput {
      display: none;
    }

    /* å…§å®¹å€åŸŸ */
    .tab-contents {
      flex-grow: 1;
      overflow: auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      position: relative;
    }

    .tab-content {
      display: none;
      min-width: max-content;
      padding: 20px;
    }

    .tab-content.active {
      display: block;
    }

    /* æ¨¹ç‹€åœ–çµæ§‹ */
    .tree-container {
      display: flex;
      flex-direction: column-reverse;
      align-items: center;
      gap: 80px;
      margin-top: 20px;
      padding: 40px;
      position: relative;
      background: white;
    }

    .tree-row {
      display: flex;
      justify-content: center;
      gap: 45px;
      position: relative;
      z-index: 2;
    }

    /* åƒç…§åˆ—æ¨£å¼ */
    .ref-row {
      opacity: 0.8;
      padding-bottom: 30px;
      margin-bottom: 10px;
      border-bottom: none;
    }

    .ref-label {
      position: absolute;
      bottom: calc(100% + 5px);
      left: 50%;
      transform: translateX(-50%);
      color: #718096;
      font-weight: bold;
      font-size: 14px;
      background: white;
      padding: 5px 10px;
      border-radius: 6px;
      white-space: nowrap;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 15px;
      z-index: 10;
    }

    .ref-node {
      cursor: not-allowed !important;
      transform: scale(0.95);
    }

    .ref-node input {
      cursor: not-allowed;
      pointer-events: none;
      background: rgba(255, 255, 255, 0.3) !important;
      border-color: transparent !important;
    }

    /* èƒŒæ™¯ç®­é ­ç•«å¸ƒ */
    .tree-svg {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 1;
    }

    /* Node æ¨£å¼ */
    .node {
      min-width: 64px;
      min-height: 64px;
      display: grid;
      grid-auto-flow: column;
      grid-template-rows: auto auto;
      grid-template-columns: auto auto;
      gap: 4px;
      border: 3px solid #718096;
      padding: 6px;
      border-radius: 8px;
      background-color: #ffffff;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
      position: relative;
      transition: border-color 0.2s, background-color 0.2s;
    }

    /* æ§åˆ¶åƒç…§å±¤é¡¯ç¤º/éš±è— */
    .hide-ref-layer .exp-node {
      display: none !important;
    }

    .node.green {
      background-color: #c6f6d5;
      border-color: #38a169;
    }

    .node.red {
      background-color: #fed7d7;
      border-color: #e53e3e;
    }

    /* æ¸¸æ¨™æ‡¸åœæ™‚çš„ O èˆ‡ X é¸æ“‡å™¨ */
    .node:not(.ref-node) .color-picker {
      position: absolute;
      top: -38px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 6px;
      background: #ffffff;
      padding: 5px;
      border-radius: 6px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      border: 1px solid #cbd5e0;
      z-index: 100;
    }

    .node:hover:not(.ref-node) .color-picker {
      display: flex;
    }

    .btn-color {
      width: 26px;
      height: 26px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-weight: bold;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .btn-color.btn-green {
      background: #38a169;
    }

    .btn-color.btn-red {
      background: #e53e3e;
    }

    .btn-color:hover {
      filter: brightness(1.1);
    }

    /* è¼¸å…¥æ¡†æ¨£å¼ */
    .node input {
      width: 3ch;
      min-width: 3ch;
      border: 1px solid #e2e8f0;
      text-align: center;
      font-size: 16px;
      font-family: 'Courier New', Courier, monospace;
      font-weight: bold;
      background: rgba(255, 255, 255, 0.6);
      box-sizing: border-box;
      outline: none;
      border-radius: 3px;
      padding: 2px 4px;
      transition: border 0.1s;
    }

    .node input:focus {
      border: 2px solid #3182ce;
      background: #fff;
    }
  </style>
</head>

<body class="hide-ref-layer">

  <div class="header-controls">
    <button class="btn" onclick="window.createTab()">+ æ–°å¢ Lv åˆ†é </button>
    <div class="pagination">
      <button class="page-btn" id="prev-btn" onclick="window.prevTab()" disabled>â—€ ä¸Šä¸€é </button>
      <span class="page-label" id="current-tab-label">è¼‰å…¥ä¸­...</span>
      <button class="page-btn" id="next-btn" onclick="window.nextTab()" disabled>ä¸‹ä¸€é  â–¶</button>
    </div>

    <div class="sync-status" id="sync-status">
      <div class="status-dot" id="status-dot"></div>
      <span id="status-text">é€£ç·šä¸­...</span>
    </div>

    <button class="btn export" onclick="window.exportToImage()">ğŸ–¼ï¸ åŒ¯å‡ºç•¶å‰ç•«é¢</button>
    <button class="btn save" onclick="window.saveData()">ğŸ’¾ å‚™ä»½ (JSON)</button>
    <button class="btn load" onclick="document.getElementById('fileInput').click()">ğŸ“‚ åŒ¯å…¥è¦†è“‹</button>
    <input type="file" id="fileInput" accept=".json" onchange="window.loadData(event)">
  </div>

  <div class="tab-contents" id="tab-contents"></div>

  <!-- ä½¿ç”¨ module å¼•å…¥ Firebase v10 SDK -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-app.js";
    import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-firestore.js";

    // 1. Firebase åˆå§‹åŒ–
    const firebaseConfig = {
      apiKey: "AIzaSyDvHGQqXkdPx496CSDMQ_aU7Q6wbz28D-g",
      authDomain: "doublechess-fe12e.firebaseapp.com",
      projectId: "doublechess-fe12e",
      storageBucket: "doublechess-fe12e.firebasestorage.app",
      messagingSenderId: "1062731143335",
      appId: "1:1062731143335:web:a69ea9a1bc97798f37a382"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const docRef = doc(db, 'research_data', 'board_state_2');

    // 2. ç‹€æ…‹è®Šæ•¸
    let tabsList = [];
    let currentIndex = 0;
    let isSyncingFromCloud = false; // é¿å…é›²ç«¯æ›´æ–°æ™‚è§¸ç™¼äºŒæ¬¡ä¸Šå‚³
    let syncTimeout = null;

    // 3. UI ç‡ˆè™Ÿæ§åˆ¶
    function setSyncStatus(status) {
      const dot = document.getElementById('status-dot');
      const text = document.getElementById('status-text');
      dot.className = 'status-dot';
      if (status === 'online') {
        dot.classList.add('online'); text.innerText = 'å·²é€£ç·šåŒæ­¥';
      } else if (status === 'syncing') {
        dot.classList.add('syncing'); text.innerText = 'å„²å­˜ä¸­...';
      } else {
        text.innerText = 'é›¢ç·š / éŒ¯èª¤';
      }
    }

    // 4. æŠ“å–ç•¶å‰æ‰€æœ‰ DOM è³‡æ–™è½‰ç‚º JSON Object
    function getAppState() {
      const data = [];
      document.querySelectorAll('.tab-content').forEach(tab => {
        const tabData = { id: tab.id, rows: [] };
        tab.querySelectorAll('.tree-row:not(.ref-row)').forEach(row => {
          const rowData = { r: row.dataset.r, nodes: [] };
          row.querySelectorAll('.node').forEach(node => {
            const nodeInfo = {
              i: node.dataset.i,
              color: node.classList.contains('green') ? 'green' : node.classList.contains('red') ? 'red' : 'white',
              vals: {}
            };
            node.querySelectorAll('input').forEach(input => {
              nodeInfo.vals[input.dataset.pos] = input.value;
            });
            rowData.nodes.push(nodeInfo);
          });
          tabData.rows.push(rowData);
        });
        data.push(tabData);
      });
      return data;
    }

    // 5. å°‡è³‡æ–™æ¨æ’­è‡³ Firebase é›²ç«¯ (Debounce é˜²æŠ–)
    function scheduleSyncToCloud() {
      if (isSyncingFromCloud) return; // å¦‚æœæ­£åœ¨æ¥æ”¶é›²ç«¯è³‡æ–™ï¼Œä¸åå‘æ¨æ’­

      setSyncStatus('syncing');
      clearTimeout(syncTimeout);
      syncTimeout = setTimeout(async () => {
        try {
          const currentState = getAppState();
          await setDoc(docRef, { state: currentState, timestamp: new Date().toISOString() });
          setSyncStatus('online');
        } catch (error) {
          console.error("Firebase å„²å­˜å¤±æ•—:", error);
          setSyncStatus('error');
        }
      }, 600); // åœæ­¢æ‰“å­—/æ“ä½œ 0.6 ç§’å¾Œè‡ªå‹•å„²å­˜
    }

    // 6. æ¥æ”¶ Firebase é›²ç«¯è³‡æ–™ä¸¦æ›´æ–° UI (é˜²æ¸¸æ¨™è·³å‹•)
    function applyDataToUI(data) {
      isSyncingFromCloud = true; // é–ä½ï¼Œé¿å…è§¸ç™¼ scheduleSyncToCloud

      // a. å»ºç«‹ç¼ºå°‘çš„ Tab
      data.forEach(tabData => {
        if (!tabsList.includes(tabData.id)) window.createTab(tabData.id, false);
      });

      // b. æ›´æ–°æ¯ä¸€åˆ—èˆ‡ç¯€é»
      data.forEach(tabData => {
        const container = document.getElementById(`tree-${tabData.id}`);
        if (!container) return;

        // è£œè¶³åˆ—æ•¸
        let currentRows = container.querySelectorAll('.tree-row:not(.ref-row)');
        while (currentRows.length < tabData.rows.length) {
          window.addRow(tabData.id, null, false);
          currentRows = container.querySelectorAll('.tree-row:not(.ref-row)');
        }
        // åˆªé™¤å¤šé¤˜çš„åˆ—æ•¸
        while (currentRows.length > tabData.rows.length) {
          container.removeChild(currentRows[currentRows.length - 1]);
          currentRows = container.querySelectorAll('.tree-row:not(.ref-row)');
        }

        // c. æ›´æ–°å…§å®¹ (é¿é–‹ç›®å‰ focus çš„è¼¸å…¥æ¡†)
        tabData.rows.forEach(rowData => {
          const rowDiv = container.querySelector(`.tree-row:not(.ref-row)[data-r="${rowData.r}"]`);
          if (rowDiv) {
            rowData.nodes.forEach(nodeData => {
              const node = rowDiv.querySelector(`.node[data-i="${nodeData.i}"]`);
              if (node) {
                if (!node.classList.contains(nodeData.color)) {
                  node.className = `node ${nodeData.color}`;
                }
                for (const pos in nodeData.vals) {
                  const input = node.querySelector(`input[data-pos="${pos}"]`);
                  // é—œéµï¼šå¦‚æœæˆ‘æ­£åœ¨æ‰“å­—ï¼Œä¸è¦ç”¨é›²ç«¯çš„èˆŠè³‡æ–™è¦†è“‹æˆ‘çš„æ¸¸æ¨™
                  if (input && input !== document.activeElement) {
                    if (input.value !== nodeData.vals[pos]) {
                      input.value = nodeData.vals[pos];
                      input.style.width = Math.max(3, input.value.length + 1) + 'ch';
                    }
                  }
                }
              }
            });
          }
        });

        updateReferenceRow(tabData.id);
        drawArrows(tabData.id);
        drawExperimentalNodes(tabData.id);
      });

      if (tabsList.length > 0 && document.querySelectorAll('.tab-content.active').length === 0) {
        window.switchTab(0);
      }

      isSyncingFromCloud = false; // è§£é™¤é–å®š
    }

    // ================= æ ¸å¿ƒé‚è¼¯å€å¡Š =================

    window.createTab = function (tabIdName = null, triggerSync = true) {
      const tabId = tabIdName || `Lv_${tabsList.length}`;
      if (!tabsList.includes(tabId)) {
        tabsList.push(tabId);
      }

      const tabContent = document.createElement('div');
      tabContent.id = tabId; tabContent.className = 'tab-content';

      const controlsDiv = document.createElement('div');
      controlsDiv.style.textAlign = 'center'; controlsDiv.style.marginBottom = '15px';

      const addRowBtn = document.createElement('button');
      addRowBtn.className = 'btn'; addRowBtn.style.marginRight = '10px';
      addRowBtn.innerText = 'â¬†ï¸ å¾€ä¸Šæ–°å¢ä¸€åˆ— Node (+2)';
      addRowBtn.onclick = () => { window.addRow(tabId); drawArrows(tabId); };

      const undoRowBtn = document.createElement('button');
      undoRowBtn.className = 'btn undo'; undoRowBtn.innerText = 'â¬‡ï¸ åˆªé™¤æœ€ä¸Šåˆ— (é‚„åŸ)';
      undoRowBtn.onclick = () => window.removeRow(tabId);

      controlsDiv.appendChild(addRowBtn); controlsDiv.appendChild(undoRowBtn);

      const treeContainer = document.createElement('div');
      treeContainer.className = 'tree-container'; treeContainer.id = `tree-${tabId}`;

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('class', 'tree-svg');
      svg.innerHTML = `<defs><marker id="arrow-${tabId}" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="5" markerHeight="5" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#a0aec0" /></marker></defs>`;
      treeContainer.appendChild(svg);

      tabContent.appendChild(controlsDiv); tabContent.appendChild(treeContainer);
      document.getElementById('tab-contents').appendChild(tabContent);

      if (!tabIdName) {
        window.addRow(tabId, null, false);
        window.switchTab(tabsList.length - 1);
      }

      if (triggerSync) scheduleSyncToCloud();
      return tabId;
    };

    window.switchTab = function (index) {
      if (index < 0 || index >= tabsList.length) return;
      currentIndex = index;
      const tabId = tabsList[currentIndex];

      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.toggle('active', content.id === tabId);
      });

      const nMatch = tabId.match(/Lv_(\d+)/);
      const lvNum = nMatch ? parseInt(nMatch[1]) : 0;
      const displayLabel = lvNum === 0 ? "Lv 4n" : `Lv 4n+${lvNum}`;
      document.getElementById('current-tab-label').innerText = displayLabel;
      document.getElementById('prev-btn').disabled = (currentIndex === 0);
      document.getElementById('next-btn').disabled = (currentIndex === tabsList.length - 1);

      updateReferenceRow(tabId);
      setTimeout(() => {
        drawArrows(tabId);
        drawExperimentalNodes(tabId);
      }, 50);
    };

    window.prevTab = function () { window.switchTab(currentIndex - 1); };
    window.nextTab = function () { window.switchTab(currentIndex + 1); };

    function updateReferenceRow(tabId) {
      const nMatch = tabId.match(/Lv_(\d+)/);
      if (!nMatch) return;
      const n = parseInt(nMatch[1]);
      if (n === 0) return;

      const sourceN = n % 2 !== 0 ? n - 1 : n - 2;
      const sourceTabId = `Lv_${sourceN}`;
      const sourceContainer = document.getElementById(`tree-${sourceTabId}`);
      if (!sourceContainer) return;

      const sourceRows = Array.from(sourceContainer.querySelectorAll('.tree-row:not(.ref-row)'));
      if (sourceRows.length === 0) return;
      const lastSourceRow = sourceRows.reduce((prev, current) => parseInt(current.dataset.r) > parseInt(prev.dataset.r) ? current : prev);

      const container = document.getElementById(`tree-${tabId}`);
      if (!container) return;

      const oldRefRow = container.querySelector('.ref-row');
      if (oldRefRow) oldRefRow.remove();

      const refRow = document.createElement('div');
      refRow.className = 'tree-row ref-row';

      const label = document.createElement('div');
      label.className = 'ref-label';
      const sourceLabel = sourceN === 0 ? "4n" : `4n+${sourceN}`;
      label.innerHTML = `<span>[ åƒç…§è‡ª Lv ${sourceLabel} çš„æœ€å¾Œä¸€åˆ— ]</span>`;

      if (n >= 1) {
        const toggleLabel = document.createElement('label');
        toggleLabel.style.display = 'flex';
        toggleLabel.style.alignItems = 'center';
        toggleLabel.style.gap = '5px';
        toggleLabel.style.cursor = 'pointer';
        toggleLabel.style.fontSize = '18px';
        toggleLabel.style.fontWeight = 'bold';
        toggleLabel.style.color = '#4a5568';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.style.width = '20px';
        checkbox.style.height = '20px';
        checkbox.checked = !document.body.classList.contains('hide-ref-layer');
        checkbox.addEventListener('change', function () {
          if (this.checked) document.body.classList.remove('hide-ref-layer');
          else document.body.classList.add('hide-ref-layer');
        });

        toggleLabel.appendChild(checkbox);
        const prevN = n - 1;
        const prevLabel = prevN === 0 ? "4n" : `4n+${prevN}`;
        toggleLabel.appendChild(document.createTextNode(`é¡¯ç¤º Lv ${prevLabel}`));
        label.appendChild(toggleLabel);
      }

      refRow.appendChild(label);

      const nodes = lastSourceRow.querySelectorAll('.node');
      nodes.forEach(sourceNode => {
        const newNode = document.createElement('div');
        const colorClass = sourceNode.classList.contains('green') ? 'green' : sourceNode.classList.contains('red') ? 'red' : 'white';
        newNode.className = `node ref-node ${colorClass}`;

        ['a', 'b', 'c', 'd'].forEach(pos => {
          const sourceInput = sourceNode.querySelector(`input[data-pos="${pos}"]`);
          const input = document.createElement('input');
          input.type = 'text'; input.dataset.pos = pos;
          input.value = sourceInput ? sourceInput.value : '';
          input.readOnly = true;
          input.style.width = sourceInput ? sourceInput.style.width : '3ch';
          newNode.appendChild(input);
        });
        refRow.appendChild(newNode);
      });

      container.appendChild(refRow);
    }

    function drawExperimentalNodes(tabId) {
      const nMatch = tabId.match(/Lv_(\d+)/);
      if (!nMatch) return;
      const n = parseInt(nMatch[1]);
      if (n < 1) return; // å¾ Lv 1 é–‹å§‹

      const container = document.getElementById(`tree-${tabId}`);
      if (!container) return;

      // æ¸…é™¤èˆŠçš„ç–ŠåŠ ç¯€é»
      container.querySelectorAll('.exp-node').forEach(n => n.remove());

      const sourceTabId = `Lv_${n - 1}`;
      const sourceContainer = document.getElementById(`tree-${sourceTabId}`);
      if (!sourceContainer) return; // å¦‚æœä¸Šä¸€å±¤é‚„æ²’å»ºç«‹å‰‡è·³é

      const sourceRows = Array.from(sourceContainer.querySelectorAll('.tree-row:not(.ref-row)'));
      if (sourceRows.length === 0) return;

      const containerRect = container.getBoundingClientRect();

      // æ±ºå®šè¦æå–çš„åƒç…§å±¤åˆ— (r)
      let rowsToExtract = [];
      if (n % 2 !== 0) {
        // nç‚ºå¥‡æ•¸æ™‚ï¼Œåƒç…§å±¤(å¶æ•¸å±¤)åªé¡¯ç¤ºé™¤äº†ç¬¬ä¸€åˆ—(r=0)å’Œæœ€å¾Œä¸€åˆ—ä»¥å¤–çš„ç¯€é»
        rowsToExtract = sourceRows.filter((row, idx) => idx !== 0 && idx !== sourceRows.length - 1);
      } else {
        // nç‚ºå¶æ•¸æ™‚ï¼Œåƒç…§å±¤(å¥‡æ•¸å±¤)åªé¡¯ç¤ºé™¤äº†ç¬¬ä¸€åˆ—(r=0)ä»¥å¤–çš„ç¯€é»
        rowsToExtract = sourceRows.filter((row, idx) => idx !== 0);
      }

      rowsToExtract.forEach(sourceRow => {
        const r_prev = parseInt(sourceRow.dataset.r);
        const sourceNodes = sourceRow.querySelectorAll('.node');

        sourceNodes.forEach(sourceNode => {
          const i_prev = parseInt(sourceNode.dataset.i);

          // è¦å‰‡ 1: lv(n-1)çš„ç¯€é»èˆ‡lv(n)çš„ç¯€é»ç”±ç¬¬ä¸€åˆ—é–‹å§‹å°é½Š
          // æ‰€ä»¥åº§æ¨™ç›´æ¥å°æ‡‰åˆ°è©²å±¤çš„ç›¸åŒ r èˆ‡ i
          const node1 = container.querySelector(`.tree-row[data-r="${r_prev}"] .node[data-i="${i_prev}"]`);

          if (node1) {
            const rect1 = node1.getBoundingClientRect();

            // å–å¾— Lv(n) è©²ç¯€é»çš„ä¸­å¿ƒé»
            const baseX = (rect1.left + rect1.right) / 2 - containerRect.left + container.scrollLeft;
            const baseY = (rect1.top + rect1.bottom) / 2 - containerRect.top + container.scrollTop;

            // X è»¸æ°´å¹³åç§»å–æ¶ˆ (0px)
            const xOffset = 0;
            // Y è»¸å‚ç›´åç§»åˆ°é–“éš™ä¸­å¤®ï¼š(ç¯€é»é«˜åº¦ + å‚ç›´gap 80px) / 2
            const yOffset = (rect1.height + 80) / 2;

            const centerX = baseX + xOffset;
            const centerY = baseY - yOffset; // Y åº§æ¨™å¾€ä¸Šæ˜¯æ¸›

            // å»ºç«‹ç–ŠåŠ ç¯€é» (Ghost Node)
            const expNode = document.createElement('div');
            const colorClass = sourceNode.classList.contains('green') ? 'green' : sourceNode.classList.contains('red') ? 'red' : 'white';
            expNode.className = `node exp-node ${colorClass}`;

            // è¨­å®šæ¨£å¼èˆ‡ä½ç§»
            expNode.style.position = 'absolute';
            expNode.style.left = `${centerX}px`;
            expNode.style.top = `${centerY}px`;
            expNode.style.transform = `translate(-50%, -50%) scale(0.85)`;
            expNode.style.zIndex = '1'; // ç¢ºä¿åœ¨èƒŒæ™¯ä½†é«˜æ–¼ç·šæ¢
            expNode.style.opacity = '0.5'; // åŠé€æ˜åœ–å±¤
            expNode.style.pointerEvents = 'none'; // ç„¡æ³•é»æ“Š

            ['a', 'b', 'c', 'd'].forEach(pos => {
              const sourceInput = sourceNode.querySelector(`input[data-pos="${pos}"]`);
              const input = document.createElement('input');
              input.type = 'text'; input.dataset.pos = pos;
              input.value = sourceInput ? sourceInput.value : '';
              input.readOnly = true;
              input.style.width = sourceInput ? sourceInput.style.width : '3ch';
              input.style.pointerEvents = 'none';
              input.style.background = 'transparent';
              input.style.borderColor = 'transparent';
              expNode.appendChild(input);
            });

            container.appendChild(expNode);
          }
        });
      });
    }

    window.addRow = function (tabId, r = null, triggerSync = true) {
      const container = document.getElementById(`tree-${tabId}`);
      const rowsCount = container.querySelectorAll('.tree-row:not(.ref-row)').length;
      const rowIndex = r !== null ? r : rowsCount;

      const rowDiv = document.createElement('div');
      rowDiv.className = 'tree-row'; rowDiv.dataset.r = rowIndex;

      const numNodes = 2 * rowIndex + 1;
      for (let i = 0; i < numNodes; i++) {
        rowDiv.appendChild(createNode(rowIndex, i, tabId));
      }

      const refRow = container.querySelector('.ref-row');
      if (refRow) container.insertBefore(rowDiv, refRow);
      else container.appendChild(rowDiv);

      drawExperimentalNodes(tabId); // é‡ç¹ªç–ŠåŠ å±¤
      if (triggerSync) scheduleSyncToCloud();
      return rowDiv;
    };

    window.removeRow = function (tabId) {
      const container = document.getElementById(`tree-${tabId}`);
      if (!container) return;
      const rows = container.querySelectorAll('.tree-row:not(.ref-row)');

      if (rows.length <= 1) {
        alert("å·²ç¶“æ˜¯ç¬¬ä¸€åˆ—åŸºç¤ç¯€é»ï¼Œç„¡æ³•å†é‚„åŸäº†ï¼"); return;
      }
      container.removeChild(rows[rows.length - 1]);
      drawArrows(tabId);
      drawExperimentalNodes(tabId); // é‡ç¹ªç–ŠåŠ å±¤
      scheduleSyncToCloud();
    };

    function createNode(r, i, tabId) {
      const node = document.createElement('div');
      node.className = 'node white'; node.dataset.i = i;

      const picker = document.createElement('div');
      picker.className = 'color-picker';
      picker.innerHTML = `
        <button class="btn-color btn-green" onclick="window.setNodeColor(event, this, 'green')">O</button>
        <button class="btn-color btn-red" onclick="window.setNodeColor(event, this, 'red')">X</button>
    `;
      node.appendChild(picker);

      ['a', 'b', 'c', 'd'].forEach(pos => {
        const input = document.createElement('input');
        input.type = 'text'; input.dataset.pos = pos;

        input.oninput = () => {
          input.style.width = Math.max(3, input.value.length + 1) + 'ch';
          syncSymmetricNode(input, r, i);
          setTimeout(() => drawArrows(tabId), 50);
          scheduleSyncToCloud(); // è¼¸å…¥æ™‚è§¸ç™¼é›²ç«¯åŒæ­¥
        };

        input.onkeydown = (e) => handleArrowKeys(e, input);
        node.appendChild(input);
      });
      return node;
    }

    window.setNodeColor = function (event, btnElement, colorClass) {
      event.stopPropagation();
      const node = btnElement.closest('.node');
      if (node.classList.contains(colorClass)) node.className = 'node white';
      else node.className = `node ${colorClass}`;
      scheduleSyncToCloud();
    };

    function syncSymmetricNode(input, r, i) {
      const val = input.value; const pos = input.dataset.pos;
      const targetI = 2 * r - i;
      if (targetI === i) return;

      const rowDiv = input.closest('.tree-row');
      const targetNode = rowDiv.querySelector(`.node[data-i="${targetI}"]`);
      if (!targetNode) return;

      let targetPos = pos === 'a' ? 'b' : pos === 'b' ? 'a' : pos === 'c' ? 'd' : 'c';
      const targetInput = targetNode.querySelector(`input[data-pos="${targetPos}"]`);
      if (targetInput) {
        targetInput.value = val;
        targetInput.style.width = Math.max(3, val.length + 1) + 'ch';
      }
    }

    function handleArrowKeys(e, input) {
      const node = input.closest('.node'); const rowDiv = input.closest('.tree-row');
      const pos = input.dataset.pos; const i = parseInt(node.dataset.i);

      const focusPos = (targetNode, p) => {
        if (targetNode) {
          const target = targetNode.querySelector(`input[data-pos="${p}"]`);
          if (target && !target.readOnly) { target.focus(); e.preventDefault(); }
        }
      };

      if (e.key === 'ArrowUp') {
        if (pos === 'b') focusPos(node, 'a');
        if (pos === 'd') focusPos(node, 'c');
      } else if (e.key === 'ArrowDown') {
        if (pos === 'a') focusPos(node, 'b');
        if (pos === 'c') focusPos(node, 'd');
      } else if (e.key === 'ArrowLeft') {
        if (input.selectionStart === 0) {
          if (pos === 'c') focusPos(node, 'a');
          else if (pos === 'd') focusPos(node, 'b');
          else if (pos === 'a' || pos === 'b') focusPos(rowDiv.querySelector(`.node[data-i="${i - 1}"]`), pos === 'a' ? 'c' : 'd');
        }
      } else if (e.key === 'ArrowRight') {
        if (input.selectionEnd === input.value.length) {
          if (pos === 'a') focusPos(node, 'c');
          else if (pos === 'b') focusPos(node, 'd');
          else if (pos === 'c' || pos === 'd') focusPos(rowDiv.querySelector(`.node[data-i="${i + 1}"]`), pos === 'c' ? 'a' : 'b');
        }
      }
    }

    function drawArrows(tabId) {
      const container = document.getElementById(`tree-${tabId}`);
      if (!container) return;
      const svg = container.querySelector('svg.tree-svg');
      if (!svg) return;

      svg.innerHTML = svg.querySelector('defs').outerHTML;
      svg.style.width = container.scrollWidth + 'px';
      svg.style.height = container.scrollHeight + 'px';

      const containerRect = container.getBoundingClientRect();
      const rows = container.querySelectorAll('.tree-row:not(.ref-row)');

      for (let r = 0; r < rows.length; r++) {
        const currentRow = container.querySelector(`.tree-row:not(.ref-row)[data-r="${r}"]`);
        const nextRow = container.querySelector(`.tree-row:not(.ref-row)[data-r="${r + 1}"]`);
        if (!currentRow) continue;

        const numNodes = 2 * r + 1;
        for (let i = 0; i < numNodes; i++) {
          const fromNode = currentRow.querySelector(`.node[data-i="${i}"]`);
          if (!fromNode) continue;

          const rectFrom = fromNode.getBoundingClientRect();
          const drawLine = (startX, startY, endX, endY) => {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startX); line.setAttribute('y1', startY);
            line.setAttribute('x2', endX); line.setAttribute('y2', endY);
            line.setAttribute('stroke', '#a0aec0'); line.setAttribute('stroke-width', '2');
            line.setAttribute('marker-end', `url(#arrow-${tabId})`);
            svg.appendChild(line);
          };

          if (nextRow) {
            const upNode = nextRow.querySelector(`.node[data-i="${i + 1}"]`);
            if (upNode) {
              const rectTo = upNode.getBoundingClientRect();
              const startX = rectFrom.left + rectFrom.width / 2 - containerRect.left + container.scrollLeft;
              const startY = rectFrom.top - containerRect.top + container.scrollTop;
              const endX = rectTo.left + rectTo.width / 2 - containerRect.left + container.scrollLeft;
              const endY = rectTo.bottom - containerRect.top + container.scrollTop;
              drawLine(startX, startY, endX, endY + 2);
            }
          }

          const drawHorizontal = (toNode, direction) => {
            if (!toNode) return;
            const rectTo = toNode.getBoundingClientRect();
            let startX, startY, endX, endY;
            if (direction === 'left') {
              startX = rectFrom.left - containerRect.left + container.scrollLeft;
              startY = rectFrom.top + rectFrom.height / 2 - containerRect.top + container.scrollTop;
              endX = rectTo.right - containerRect.left + container.scrollLeft;
              endY = rectTo.top + rectTo.height / 2 - containerRect.top + container.scrollTop;
              drawLine(startX, startY, endX + 8, endY);
            } else {
              startX = rectFrom.right - containerRect.left + container.scrollLeft;
              startY = rectFrom.top + rectFrom.height / 2 - containerRect.top + container.scrollTop;
              endX = rectTo.left - containerRect.left + container.scrollLeft;
              endY = rectTo.top + rectTo.height / 2 - containerRect.top + container.scrollTop;
              drawLine(startX, startY, endX - 8, endY);
            }
          };

          if (i === r) {
            drawHorizontal(currentRow.querySelector(`.node[data-i="${i - 1}"]`), 'left');
            drawHorizontal(currentRow.querySelector(`.node[data-i="${i + 1}"]`), 'right');
          } else if (i < r) {
            drawHorizontal(currentRow.querySelector(`.node[data-i="${i - 1}"]`), 'left');
          } else if (i > r) {
            drawHorizontal(currentRow.querySelector(`.node[data-i="${i + 1}"]`), 'right');
          }
        }
      }

      // è™•ç†æœ€å¾Œä¸€åˆ—é€£ç·šåˆ°åƒç…§åˆ— (Reference Row)
      const refRow = container.querySelector('.ref-row');
      if (refRow && rows.length > 0) {
        const lastRow = rows[rows.length - 1];
        const r = parseInt(lastRow.dataset.r);
        const numNodes = 2 * r + 1;
        const refNodes = Array.from(refRow.querySelectorAll('.node'));
        const refR = (refNodes.length - 1) / 2;

        for (let i = 0; i < numNodes; i++) {
          const fromNode = lastRow.querySelector(`.node[data-i="${i}"]`);
          if (!fromNode) continue;

          const rectFrom = fromNode.getBoundingClientRect();
          const drawLine = (startX, startY, endX, endY) => {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startX); line.setAttribute('y1', startY);
            line.setAttribute('x2', endX); line.setAttribute('y2', endY);
            line.setAttribute('stroke', '#a0aec0'); line.setAttribute('stroke-width', '2');
            line.setAttribute('marker-end', `url(#arrow-${tabId})`);
            svg.appendChild(line);
          };

          const offset = i - r; // èˆ‡ä¸­è»¸çš„è·é›¢ (- for left, + for right)

          // æ‰¾å°‹å°æ‡‰çš„ target ç¯€é» (æ­£ä¸Šæ–¹)
          const targetI_up = refR + offset;
          if (targetI_up >= 0 && targetI_up < refNodes.length) {
            const upNode = refNodes[targetI_up];
            if (upNode) {
              const rectTo = upNode.getBoundingClientRect();
              const startX = rectFrom.left + rectFrom.width / 2 - containerRect.left + container.scrollLeft;
              const startY = rectFrom.top - containerRect.top + container.scrollTop;
              const endX = rectTo.left + rectTo.width / 2 - containerRect.left + container.scrollLeft;
              const endY = rectTo.bottom - containerRect.top + container.scrollTop;
              drawLine(startX, startY, endX, endY + 4);
            }
          }

          // æ‰¾å°‹å°æ‡‰çš„ target ç¯€é» (å·¦å‰æ–¹/å³å‰æ–¹)
          if (offset !== 0) { // éä¸­è»¸
            // å°æ–¼å·¦å´ç¯€é»ï¼Œå³å‰æ–¹ä»£è¡¨è·é›¢ä¸­è»¸è¿‘ 1 æ ¼ (+1)
            // å°æ–¼å³å´ç¯€é»ï¼Œå·¦å‰æ–¹ä»£è¡¨è·é›¢ä¸­è»¸è¿‘ 1 æ ¼ (-1)
            const diagOffset = offset > 0 ? offset - 1 : offset + 1;
            const targetI_diag = refR + diagOffset;

            if (targetI_diag >= 0 && targetI_diag < refNodes.length) {
              const diagNode = refNodes[targetI_diag];
              if (diagNode) {
                const rectTo = diagNode.getBoundingClientRect();
                const startX = rectFrom.left + rectFrom.width / 2 - containerRect.left + container.scrollLeft;
                const startY = rectFrom.top - containerRect.top + container.scrollTop;
                let endX = rectTo.left + rectTo.width / 2 - containerRect.left + container.scrollLeft;
                const endY = rectTo.bottom - containerRect.top + container.scrollTop;

                // ç‚ºäº†é¿å…èˆ‡æ­£ä¸‹æ–¹ä¸Šä¾†çš„ç®­é ­é‡ç–Šï¼Œå¾®èª¿æ–œå‘ç®­é ­çš„å°¾ç«¯ä½ç½®
                if (offset < 0) {
                  // å·¦å´ç¯€é»å¾€å³ä¸Šæ–¹é€£ï¼šç®­é ­å°¾ç«¯ç•¥å¾€å·¦ç§»
                  endX -= 12;
                } else if (offset > 0) {
                  // å³å´ç¯€é»å¾€å·¦ä¸Šæ–¹é€£ï¼šç®­é ­å°¾ç«¯ç•¥å¾€å³ç§»
                  endX += 12;
                }

                drawLine(startX, startY, endX, endY + 4);
              }
            }
          } else {
            // é‡å°ä¸­è»¸ç¯€é» (offset == 0) é€£æ¥åˆ°æ­£ä¸Šæ–¹ï¼Œå·²ç¶“ç”±ä¸Šé¢ targetI_up è™•ç†éäº†
          }
        }
      }
    }

    window.addEventListener('resize', () => {
      const activeTab = document.querySelector('.tab-content.active');
      if (activeTab) {
        drawArrows(activeTab.id);
        drawExperimentalNodes(activeTab.id);
      }
    });

    // ================= è¼¸å‡ºèˆ‡æœ¬åœ°å‚™ä»½ =================
    window.exportToImage = function () {
      const activeTab = document.querySelector('.tab-content.active .tree-container');
      if (!activeTab) return;
      const pickers = activeTab.querySelectorAll('.color-picker');
      pickers.forEach(p => p.style.display = 'none');

      html2canvas(activeTab, { backgroundColor: "#ffffff", scale: 2 }).then(canvas => {
        const link = document.createElement('a');
        link.download = `çŸ©é™£ç´€éŒ„_${new Date().getTime()}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
        pickers.forEach(p => p.style.display = '');
      });
    };

    window.saveData = function () {
      const data = getAppState();
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `å°ˆé¡Œç´€éŒ„_${new Date().toISOString().slice(0, 10)}.json`;
      link.click();
    };

    window.loadData = function (event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const data = JSON.parse(e.target.result);
          applyDataToUI(data);
          scheduleSyncToCloud(); // åŒ¯å…¥æˆåŠŸå¾Œï¼Œå¼·åˆ¶æ¨æ’­çµ¦å…¶ä»–çµ„å“¡
          alert("é€²åº¦åŒ¯å…¥æˆåŠŸï¼å·²åŒæ­¥è‡³é›²ç«¯ã€‚");
        } catch (err) { alert("æª”æ¡ˆæ ¼å¼éŒ¯èª¤æˆ–ææ¯€ã€‚"); }
      };
      reader.readAsText(file);
      event.target.value = "";
    };

    // ================= åˆå§‹åŒ–é€£ç·šç›£è½ =================
    setSyncStatus('syncing');

    onSnapshot(docRef, (docSnap) => {
      if (docSnap.exists() && docSnap.data().state) {
        // å¦‚æœé›²ç«¯æœ‰è³‡æ–™ï¼Œå°±ç”¨é›²ç«¯çš„è³‡æ–™ç¹ªè£½ç•«é¢
        applyDataToUI(docSnap.data().state);
        setSyncStatus('online');
      } else {
        // ç¬¬ä¸€å€‹é–‹å•Ÿé€™å€‹å°ˆæ¡ˆçš„äººï¼šå»ºç«‹ç©ºç™½çš„ç¬¬ä¸€é ï¼Œä¸¦æ¨æ’­çµ¦é›²ç«¯
        if (tabsList.length === 0) {
          window.createTab();
        }
      }
    }, (error) => {
      console.error("Firestore ç›£è½å¤±æ•— (è«‹ç¢ºèª Rules æ˜¯å¦ç‚ºå…è¨±è®€å¯«):", error);
      setSyncStatus('error');
      if (tabsList.length === 0) window.createTab(null, false); // é›¢ç·šç‹€æ…‹ä¸‹è‡³å°‘èƒ½æœ¬æ©Ÿé‹ä½œ
    });

  </script>
</body>

</html>